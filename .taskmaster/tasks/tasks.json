{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Projects API Manager",
        "description": "Create a ProjectsManager class to handle all CRUD operations for projects, including linking to clients and contracts, status management, task assignment, and timeline tracking.",
        "details": "Create a new file `projects.py` in the managers directory following the existing pattern:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import Project, ProjectStatus, ProjectTask, ProjectTimeline\n\nclass ProjectsManager(BaseManager):\n    \"\"\"Manager for SuperOps Projects API operations\"\"\"\n    \n    async def get(self, project_id: str) -> Project:\n        \"\"\"Get a project by ID\"\"\"\n        query = self._build_get_query(project_id)\n        response = await self._execute(query)\n        return Project(**response['data']['project'])\n    \n    async def list(self, client_id: Optional[str] = None, status: Optional[ProjectStatus] = None) -> List[Project]:\n        \"\"\"List projects with optional filtering\"\"\"\n        query = self._build_list_query(client_id, status)\n        response = await self._execute(query)\n        return [Project(**p) for p in response['data']['projects']]\n    \n    async def create(self, data: Dict[str, Any]) -> Project:\n        \"\"\"Create a new project\"\"\"\n        mutation = self._build_create_mutation(data)\n        response = await self._execute(mutation)\n        return Project(**response['data']['createProject'])\n    \n    async def update(self, project_id: str, data: Dict[str, Any]) -> Project:\n        \"\"\"Update an existing project\"\"\"\n        mutation = self._build_update_mutation(project_id, data)\n        response = await self._execute(mutation)\n        return Project(**response['data']['updateProject'])\n    \n    async def delete(self, project_id: str) -> bool:\n        \"\"\"Delete a project\"\"\"\n        mutation = self._build_delete_mutation(project_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteProject']['success']\n    \n    async def assign_task(self, project_id: str, task_id: str) -> Project:\n        \"\"\"Assign a task to a project\"\"\"\n        mutation = self._build_assign_task_mutation(project_id, task_id)\n        response = await self._execute(mutation)\n        return Project(**response['data']['assignTaskToProject'])\n    \n    async def update_timeline(self, project_id: str, timeline_data: Dict[str, Any]) -> ProjectTimeline:\n        \"\"\"Update project timeline and milestones\"\"\"\n        mutation = self._build_timeline_mutation(project_id, timeline_data)\n        response = await self._execute(mutation)\n        return ProjectTimeline(**response['data']['updateProjectTimeline'])\n    \n    def _build_get_query(self, project_id: str) -> str:\n        # Implement GraphQL query builder\n        pass\n    \n    # Implement other query/mutation builders\n```\n\nAlso create corresponding type definitions in `types.py`:\n\n```python\nclass ProjectStatus(str, Enum):\n    PLANNING = \"planning\"\n    IN_PROGRESS = \"in_progress\"\n    ON_HOLD = \"on_hold\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n\nclass ProjectTimeline:\n    id: str\n    start_date: datetime\n    end_date: datetime\n    milestones: List[ProjectMilestone]\n    # other fields\n\nclass ProjectMilestone:\n    id: str\n    name: str\n    due_date: datetime\n    status: str\n    # other fields\n\nclass Project:\n    id: str\n    name: str\n    description: str\n    client_id: str\n    status: ProjectStatus\n    created_at: datetime\n    updated_at: datetime\n    tasks: List[ProjectTask]\n    timeline: ProjectTimeline\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_projects.py` that:\n1. Mock GraphQL responses for all CRUD operations\n2. Test project creation with required and optional fields\n3. Test project retrieval by ID\n4. Test project listing with various filters\n5. Test project updates\n6. Test project deletion\n7. Test task assignment to projects\n8. Test timeline and milestone management\n9. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Project-Related Types in types.py",
            "description": "Create and update type definitions for Project, ProjectStatus, ProjectTask, ProjectTimeline, and related entities in types.py to support all required fields and relationships.",
            "dependencies": [],
            "details": "Review the requirements for project management, including CRUD operations, status management, task assignment, and timeline tracking. Define or update the necessary classes and enums in types.py, ensuring all fields (such as client_id, contract linkage, status, tasks, and timeline) are represented. Use Python typing and datetime as appropriate.",
            "status": "done",
            "testStrategy": "Write type-checking tests and instantiate each type with sample data to ensure correct structure and field validation."
          },
          {
            "id": 2,
            "title": "Implement ProjectsManager Class Skeleton and CRUD Methods",
            "description": "Create the ProjectsManager class in projects.py, inheriting from BaseManager, and implement async methods for get, list, create, update, and delete operations.",
            "dependencies": [],
            "details": "Follow the existing manager pattern. Implement the ProjectsManager class with async methods for get, list, create, update, and delete. Each method should call a corresponding private query/mutation builder and handle the response, returning the appropriate type instance. Use the types defined in types.py.",
            "status": "done",
            "testStrategy": "Write unit tests that mock GraphQL responses for each CRUD method, verifying correct request construction and response parsing."
          },
          {
            "id": 3,
            "title": "Implement Project Task Assignment and Timeline Management Methods",
            "description": "Add async methods to ProjectsManager for assigning tasks to projects and updating project timelines, including private mutation builders.",
            "dependencies": [],
            "details": "Implement assign_task and update_timeline methods in ProjectsManager. Each should build the appropriate mutation, execute it, and return the updated Project or ProjectTimeline object. Ensure that task assignment and timeline updates are reflected in the returned data structures.",
            "status": "done",
            "testStrategy": "Write unit tests that mock GraphQL responses for task assignment and timeline updates, verifying correct mutation construction and response handling."
          },
          {
            "id": 4,
            "title": "Implement Private Query and Mutation Builder Methods",
            "description": "Develop private helper methods in ProjectsManager to construct GraphQL queries and mutations for all supported operations, ensuring correct field mapping and parameterization.",
            "dependencies": [],
            "details": "For each public method (get, list, create, update, delete, assign_task, update_timeline), implement a corresponding private method (e.g., _build_get_query) that returns the correct GraphQL query or mutation string. Ensure all required fields and relationships are included, and parameters are safely injected.",
            "status": "done",
            "testStrategy": "Write unit tests for each builder method, asserting that the generated query/mutation strings match expected GraphQL syntax and include all necessary fields."
          },
          {
            "id": 5,
            "title": "Develop Comprehensive Unit Tests for ProjectsManager",
            "description": "Create a test suite in tests/test_projects.py to cover all ProjectsManager methods, including CRUD, task assignment, and timeline management, using mocked API responses.",
            "dependencies": [],
            "details": "Write tests for each ProjectsManager method, mocking GraphQL responses and verifying correct behavior for normal and edge cases. Include tests for project creation with required/optional fields, retrieval by ID, listing with filters, updates, deletion, task assignment, and timeline updates.",
            "status": "done",
            "testStrategy": "Use a testing framework (e.g., pytest, unittest) with async support and mocking libraries to simulate API responses. Ensure all code paths and error conditions are tested."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Tasks API Manager",
        "description": "Create a TasksManager class to handle standalone task management, task-to-project linking, assignment, status workflows, priority management, and recurring task support.",
        "details": "Create a new file `tasks.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime, timedelta\n\nfrom ..base import BaseManager\nfrom ..types import Task, TaskStatus, TaskPriority, RecurringTaskConfig\n\nclass TasksManager(BaseManager):\n    \"\"\"Manager for SuperOps Tasks API operations\"\"\"\n    \n    async def get(self, task_id: str) -> Task:\n        \"\"\"Get a task by ID\"\"\"\n        query = self._build_get_query(task_id)\n        response = await self._execute(query)\n        return Task(**response['data']['task'])\n    \n    async def list(self, \n                   assignee_id: Optional[str] = None, \n                   status: Optional[TaskStatus] = None,\n                   priority: Optional[TaskPriority] = None,\n                   project_id: Optional[str] = None) -> List[Task]:\n        \"\"\"List tasks with optional filtering\"\"\"\n        query = self._build_list_query(assignee_id, status, priority, project_id)\n        response = await self._execute(query)\n        return [Task(**t) for t in response['data']['tasks']]\n    \n    async def create(self, data: Dict[str, Any]) -> Task:\n        \"\"\"Create a new task\"\"\"\n        mutation = self._build_create_mutation(data)\n        response = await self._execute(mutation)\n        return Task(**response['data']['createTask'])\n    \n    async def update(self, task_id: str, data: Dict[str, Any]) -> Task:\n        \"\"\"Update an existing task\"\"\"\n        mutation = self._build_update_mutation(task_id, data)\n        response = await self._execute(mutation)\n        return Task(**response['data']['updateTask'])\n    \n    async def delete(self, task_id: str) -> bool:\n        \"\"\"Delete a task\"\"\"\n        mutation = self._build_delete_mutation(task_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteTask']['success']\n    \n    async def assign(self, task_id: str, assignee_id: str) -> Task:\n        \"\"\"Assign a task to a user\"\"\"\n        mutation = self._build_assign_mutation(task_id, assignee_id)\n        response = await self._execute(mutation)\n        return Task(**response['data']['assignTask'])\n    \n    async def set_recurring(self, task_id: str, config: RecurringTaskConfig) -> Task:\n        \"\"\"Configure a task to recur based on specified configuration\"\"\"\n        mutation = self._build_recurring_mutation(task_id, config)\n        response = await self._execute(mutation)\n        return Task(**response['data']['setTaskRecurring'])\n    \n    async def update_status(self, task_id: str, status: TaskStatus) -> Task:\n        \"\"\"Update task status\"\"\"\n        mutation = self._build_status_mutation(task_id, status)\n        response = await self._execute(mutation)\n        return Task(**response['data']['updateTaskStatus'])\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass TaskStatus(str, Enum):\n    TODO = \"todo\"\n    IN_PROGRESS = \"in_progress\"\n    REVIEW = \"review\"\n    DONE = \"done\"\n    CANCELLED = \"cancelled\"\n\nclass TaskPriority(str, Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\nclass RecurringTaskConfig:\n    frequency: str  # daily, weekly, monthly, etc.\n    interval: int  # every X days/weeks/etc.\n    end_date: Optional[datetime]\n    max_occurrences: Optional[int]\n    # other fields\n\nclass Task:\n    id: str\n    title: str\n    description: str\n    status: TaskStatus\n    priority: TaskPriority\n    assignee_id: Optional[str]\n    project_id: Optional[str]\n    due_date: Optional[datetime]\n    created_at: datetime\n    updated_at: datetime\n    recurring_config: Optional[RecurringTaskConfig]\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_tasks.py` that:\n1. Mock GraphQL responses for all CRUD operations\n2. Test task creation with required and optional fields\n3. Test task retrieval by ID\n4. Test task listing with various filters\n5. Test task updates\n6. Test task deletion\n7. Test task assignment\n8. Test status workflow transitions\n9. Test recurring task configuration\n10. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GraphQL query builders for task operations",
            "description": "Create the GraphQL query and mutation builder methods for all task operations including get, list, create, update, delete, assign, set_recurring, and update_status.",
            "dependencies": [],
            "details": "Implement the following methods in the TasksManager class:\n\n1. `_build_get_query(task_id)`: Build GraphQL query to fetch a task by ID\n2. `_build_list_query(assignee_id, status, priority, project_id)`: Build GraphQL query with filters\n3. `_build_create_mutation(data)`: Build GraphQL mutation for task creation\n4. `_build_update_mutation(task_id, data)`: Build GraphQL mutation for task updates\n5. `_build_delete_mutation(task_id)`: Build GraphQL mutation for task deletion\n6. `_build_assign_mutation(task_id, assignee_id)`: Build GraphQL mutation for task assignment\n7. `_build_recurring_mutation(task_id, config)`: Build GraphQL mutation for recurring task setup\n8. `_build_status_mutation(task_id, status)`: Build GraphQL mutation for status updates\n\nEnsure each method returns a properly formatted GraphQL query/mutation string with all necessary variables.",
            "status": "done",
            "testStrategy": "Test each query builder method by verifying the output GraphQL strings match expected formats. Ensure variables are properly included and formatted correctly."
          },
          {
            "id": 2,
            "title": "Complete Task and RecurringTaskConfig type definitions",
            "description": "Finalize the Task and RecurringTaskConfig classes in types.py with all required fields, proper typing, and validation logic.",
            "dependencies": [],
            "details": "Enhance the Task and RecurringTaskConfig classes in types.py:\n\n1. Complete the RecurringTaskConfig class with proper type annotations:\n   - Add validation for frequency values\n   - Implement proper datetime handling for end_date\n   - Add methods to calculate next occurrence\n\n2. Complete the Task class with:\n   - All required fields with proper type annotations\n   - Add validation methods for status transitions\n   - Add helper methods for checking if task is overdue\n   - Add methods for handling recurring task logic\n\nEnsure both classes have proper docstrings and follow the project's type definition patterns.",
            "status": "done",
            "testStrategy": "Create unit tests to verify proper instantiation of Task and RecurringTaskConfig objects, validation of field values, and correct behavior of helper methods."
          },
          {
            "id": 3,
            "title": "Implement task filtering and pagination logic",
            "description": "Enhance the list method to support advanced filtering, sorting, and pagination for task queries.",
            "dependencies": [],
            "details": "Modify the `list` method in TasksManager to support:\n\n1. Additional filtering parameters:\n   - due_date_range: Optional[Tuple[datetime, datetime]]\n   - created_after: Optional[datetime]\n   - search_term: Optional[str] for title/description search\n   - tags: Optional[List[str]]\n\n2. Sorting options:\n   - sort_by: Optional[str] (e.g., 'due_date', 'priority', 'created_at')\n   - sort_order: Optional[str] ('asc' or 'desc')\n\n3. Pagination:\n   - page: Optional[int]\n   - page_size: Optional[int]\n\nUpdate the `_build_list_query` method to incorporate these parameters into the GraphQL query. Implement proper handling of cursor-based pagination if the API supports it.",
            "status": "done",
            "testStrategy": "Test the enhanced list method with various combinations of filters, sorting options, and pagination parameters. Verify correct query construction and result handling."
          },
          {
            "id": 4,
            "title": "Implement task relationship management methods",
            "description": "Add methods to handle relationships between tasks and other entities like projects, subtasks, dependencies, and comments.",
            "dependencies": [],
            "details": "Add the following methods to TasksManager:\n\n1. `async def link_to_project(self, task_id: str, project_id: str) -> Task`\n   - Links a task to a project\n\n2. `async def unlink_from_project(self, task_id: str) -> Task`\n   - Removes a task from its project\n\n3. `async def add_subtask(self, parent_id: str, subtask_data: Dict[str, Any]) -> Task`\n   - Creates a subtask under a parent task\n\n4. `async def list_subtasks(self, parent_id: str) -> List[Task]`\n   - Lists all subtasks for a given parent task\n\n5. `async def add_dependency(self, task_id: str, depends_on_id: str) -> bool`\n   - Adds a dependency relationship between tasks\n\n6. `async def remove_dependency(self, task_id: str, depends_on_id: str) -> bool`\n   - Removes a dependency relationship\n\n7. `async def add_comment(self, task_id: str, comment: str) -> Dict[str, Any]`\n   - Adds a comment to a task\n\nImplement the corresponding GraphQL mutation builders for each method.",
            "status": "done",
            "testStrategy": "Create unit tests for each relationship management method, verifying proper GraphQL mutation construction and response handling."
          },
          {
            "id": 5,
            "title": "Implement recurring task management logic",
            "description": "Enhance the recurring task functionality with methods to manage recurring task instances, schedules, and exceptions.",
            "dependencies": [],
            "details": "Enhance recurring task functionality with these methods:\n\n1. `async def get_recurring_instances(self, task_id: str, start_date: datetime, end_date: datetime) -> List[Task]`\n   - Gets all instances of a recurring task in a date range\n\n2. `async def update_recurring_config(self, task_id: str, config: RecurringTaskConfig) -> Task`\n   - Updates the recurring configuration of a task\n\n3. `async def cancel_recurring(self, task_id: str) -> Task`\n   - Cancels the recurring nature of a task\n\n4. `async def skip_occurrence(self, task_id: str, occurrence_date: datetime) -> bool`\n   - Skips a specific occurrence of a recurring task\n\n5. `async def reschedule_occurrence(self, task_id: str, occurrence_date: datetime, new_date: datetime) -> Task`\n   - Reschedules a specific occurrence\n\nImplement helper methods to calculate occurrence dates based on different recurring patterns (daily, weekly, monthly, etc.) and handle exceptions to the recurring schedule.",
            "status": "done",
            "testStrategy": "Test recurring task methods with various configuration scenarios. Verify correct calculation of occurrence dates, proper handling of exceptions, and correct API interactions for all recurring task operations."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Contracts API Manager",
        "description": "Create a ContractsManager class to handle service contract creation and management, contract-to-client association, contract value tracking, renewal workflows, and SLA management.",
        "details": "Create a new file `contracts.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import Contract, ContractStatus, SLA\n\nclass ContractsManager(BaseManager):\n    \"\"\"Manager for SuperOps Contracts API operations\"\"\"\n    \n    async def get(self, contract_id: str) -> Contract:\n        \"\"\"Get a contract by ID\"\"\"\n        query = self._build_get_query(contract_id)\n        response = await self._execute(query)\n        return Contract(**response['data']['contract'])\n    \n    async def list(self, \n                   client_id: Optional[str] = None, \n                   status: Optional[ContractStatus] = None) -> List[Contract]:\n        \"\"\"List contracts with optional filtering\"\"\"\n        query = self._build_list_query(client_id, status)\n        response = await self._execute(query)\n        return [Contract(**c) for c in response['data']['contracts']]\n    \n    async def create(self, data: Dict[str, Any]) -> Contract:\n        \"\"\"Create a new contract\"\"\"\n        mutation = self._build_create_mutation(data)\n        response = await self._execute(mutation)\n        return Contract(**response['data']['createContract'])\n    \n    async def update(self, contract_id: str, data: Dict[str, Any]) -> Contract:\n        \"\"\"Update an existing contract\"\"\"\n        mutation = self._build_update_mutation(contract_id, data)\n        response = await self._execute(mutation)\n        return Contract(**response['data']['updateContract'])\n    \n    async def delete(self, contract_id: str) -> bool:\n        \"\"\"Delete a contract\"\"\"\n        mutation = self._build_delete_mutation(contract_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteContract']['success']\n    \n    async def renew(self, contract_id: str, renewal_data: Dict[str, Any]) -> Contract:\n        \"\"\"Renew a contract\"\"\"\n        mutation = self._build_renewal_mutation(contract_id, renewal_data)\n        response = await self._execute(mutation)\n        return Contract(**response['data']['renewContract'])\n    \n    async def update_sla(self, contract_id: str, sla_data: Dict[str, Any]) -> SLA:\n        \"\"\"Update SLA for a contract\"\"\"\n        mutation = self._build_sla_mutation(contract_id, sla_data)\n        response = await self._execute(mutation)\n        return SLA(**response['data']['updateContractSLA'])\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass ContractStatus(str, Enum):\n    DRAFT = \"draft\"\n    ACTIVE = \"active\"\n    EXPIRED = \"expired\"\n    TERMINATED = \"terminated\"\n    RENEWED = \"renewed\"\n\nclass SLAResponseTime(str, Enum):\n    ONE_HOUR = \"1h\"\n    FOUR_HOURS = \"4h\"\n    EIGHT_HOURS = \"8h\"\n    NEXT_BUSINESS_DAY = \"next_business_day\"\n    # other options\n\nclass SLA:\n    id: str\n    name: str\n    description: Optional[str]\n    response_times: Dict[str, SLAResponseTime]  # priority -> response time\n    resolution_times: Dict[str, str]  # priority -> resolution time\n    business_hours: Dict[str, Any]  # business hours configuration\n    # other fields\n\nclass Contract:\n    id: str\n    name: str\n    description: Optional[str]\n    client_id: str\n    status: ContractStatus\n    start_date: datetime\n    end_date: datetime\n    value: float\n    billing_frequency: str\n    auto_renew: bool\n    renewal_notice_days: int\n    sla: Optional[SLA]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_contracts.py` that:\n1. Mock GraphQL responses for all CRUD operations\n2. Test contract creation with required and optional fields\n3. Test contract retrieval by ID\n4. Test contract listing with various filters\n5. Test contract updates\n6. Test contract deletion\n7. Test contract renewal process\n8. Test SLA management\n9. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GraphQL Query Builders for Contracts",
            "description": "Create the GraphQL query and mutation builder methods for the ContractsManager class to support all contract operations.",
            "dependencies": [],
            "details": "Implement the following methods in the ContractsManager class:\n\n1. `_build_get_query(contract_id)`: Build GraphQL query to fetch a single contract by ID\n2. `_build_list_query(client_id, status)`: Build GraphQL query to list contracts with optional filters\n3. `_build_create_mutation(data)`: Build GraphQL mutation to create a new contract\n4. `_build_update_mutation(contract_id, data)`: Build GraphQL mutation to update an existing contract\n5. `_build_delete_mutation(contract_id)`: Build GraphQL mutation to delete a contract\n\nEnsure each query/mutation includes all necessary fields from the Contract type.",
            "status": "done",
            "testStrategy": "Create unit tests that verify each query builder generates the correct GraphQL syntax with proper variables. Test with various input combinations."
          },
          {
            "id": 2,
            "title": "Implement Contract Renewal and SLA Mutation Builders",
            "description": "Create the specialized GraphQL mutation builders for contract renewal and SLA management.",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement the following methods in the ContractsManager class:\n\n1. `_build_renewal_mutation(contract_id, renewal_data)`: Build GraphQL mutation for contract renewal with new terms\n2. `_build_sla_mutation(contract_id, sla_data)`: Build GraphQL mutation to update SLA settings for a contract\n\nEnsure these mutations handle all required fields and properly format the input data according to the API requirements.",
            "status": "done",
            "testStrategy": "Create unit tests that verify the renewal and SLA mutation builders generate the correct GraphQL syntax with proper variables. Test with various renewal scenarios and SLA configurations."
          },
          {
            "id": 3,
            "title": "Complete Type Definitions for Contracts",
            "description": "Finalize the Contract and SLA type definitions in types.py with all required fields and proper typing.",
            "dependencies": [],
            "details": "Enhance the type definitions in types.py:\n\n1. Complete the ContractStatus enum with all possible statuses\n2. Finalize the SLA class with all required fields for SLA management\n3. Complete the Contract class with all fields needed for contract operations\n4. Add any additional helper types needed (e.g., BillingFrequency enum)\n\nEnsure all types use proper Python typing annotations and include docstrings.",
            "status": "done",
            "testStrategy": "Create unit tests that verify the type definitions can properly serialize and deserialize sample API responses."
          },
          {
            "id": 4,
            "title": "Implement Contract Value Tracking Methods",
            "description": "Add specialized methods to the ContractsManager for tracking and calculating contract values, including forecasting and reporting.",
            "dependencies": [
              "3.1",
              "3.3"
            ],
            "details": "Add the following methods to the ContractsManager class:\n\n1. `async def calculate_total_value(self, contract_id: str) -> float`: Calculate the total value of a contract over its entire term\n2. `async def forecast_revenue(self, client_id: Optional[str] = None, months: int = 12) -> Dict[str, float]`: Generate a monthly revenue forecast based on active contracts\n3. `async def get_expiring_contracts(self, days: int = 30) -> List[Contract]`: Get contracts expiring within the specified number of days\n\nImplement the necessary GraphQL queries to support these operations.",
            "status": "done",
            "testStrategy": "Create unit tests that verify the contract value tracking methods correctly calculate values and forecasts. Test with various contract scenarios including different billing frequencies and term lengths."
          },
          {
            "id": 5,
            "title": "Implement Contract-to-Client Association Methods",
            "description": "Add methods to manage the relationship between contracts and clients, including bulk operations.",
            "dependencies": [
              "3.1",
              "3.3"
            ],
            "details": "Add the following methods to the ContractsManager class:\n\n1. `async def get_client_contracts(self, client_id: str) -> List[Contract]`: Get all contracts for a specific client\n2. `async def transfer_contracts(self, from_client_id: str, to_client_id: str) -> bool`: Transfer all contracts from one client to another\n3. `async def get_contracts_by_value(self, min_value: float = 0, max_value: Optional[float] = None) -> List[Contract]`: Get contracts filtered by their value\n\nImplement the necessary GraphQL queries and mutations to support these operations.",
            "status": "done",
            "testStrategy": "Create unit tests that verify the client association methods correctly retrieve and modify contract-client relationships. Test with various client scenarios including clients with multiple contracts."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Time Entries API Manager",
        "description": "Create a TimeEntriesManager class to handle time tracking for tickets, tasks, and projects, including billable vs non-billable time, approval workflows, bulk operations, and reporting.",
        "details": "Create a new file `time_entries.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime, timedelta\n\nfrom ..base import BaseManager\nfrom ..types import TimeEntry, TimeEntryStatus, TimeEntryType\n\nclass TimeEntriesManager(BaseManager):\n    \"\"\"Manager for SuperOps Time Entries API operations\"\"\"\n    \n    async def get(self, time_entry_id: str) -> TimeEntry:\n        \"\"\"Get a time entry by ID\"\"\"\n        query = self._build_get_query(time_entry_id)\n        response = await self._execute(query)\n        return TimeEntry(**response['data']['timeEntry'])\n    \n    async def list(self, \n                   user_id: Optional[str] = None,\n                   entity_type: Optional[TimeEntryType] = None,\n                   entity_id: Optional[str] = None,\n                   start_date: Optional[datetime] = None,\n                   end_date: Optional[datetime] = None,\n                   billable: Optional[bool] = None,\n                   status: Optional[TimeEntryStatus] = None) -> List[TimeEntry]:\n        \"\"\"List time entries with optional filtering\"\"\"\n        query = self._build_list_query(user_id, entity_type, entity_id, start_date, end_date, billable, status)\n        response = await self._execute(query)\n        return [TimeEntry(**t) for t in response['data']['timeEntries']]\n    \n    async def create(self, data: Dict[str, Any]) -> TimeEntry:\n        \"\"\"Create a new time entry\"\"\"\n        mutation = self._build_create_mutation(data)\n        response = await self._execute(mutation)\n        return TimeEntry(**response['data']['createTimeEntry'])\n    \n    async def update(self, time_entry_id: str, data: Dict[str, Any]) -> TimeEntry:\n        \"\"\"Update an existing time entry\"\"\"\n        mutation = self._build_update_mutation(time_entry_id, data)\n        response = await self._execute(mutation)\n        return TimeEntry(**response['data']['updateTimeEntry'])\n    \n    async def delete(self, time_entry_id: str) -> bool:\n        \"\"\"Delete a time entry\"\"\"\n        mutation = self._build_delete_mutation(time_entry_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteTimeEntry']['success']\n    \n    async def submit_for_approval(self, time_entry_ids: List[str]) -> List[TimeEntry]:\n        \"\"\"Submit time entries for approval\"\"\"\n        mutation = self._build_submit_mutation(time_entry_ids)\n        response = await self._execute(mutation)\n        return [TimeEntry(**t) for t in response['data']['submitTimeEntriesForApproval']]\n    \n    async def approve(self, time_entry_ids: List[str]) -> List[TimeEntry]:\n        \"\"\"Approve time entries\"\"\"\n        mutation = self._build_approve_mutation(time_entry_ids)\n        response = await self._execute(mutation)\n        return [TimeEntry(**t) for t in response['data']['approveTimeEntries']]\n    \n    async def reject(self, time_entry_ids: List[str], reason: str) -> List[TimeEntry]:\n        \"\"\"Reject time entries\"\"\"\n        mutation = self._build_reject_mutation(time_entry_ids, reason)\n        response = await self._execute(mutation)\n        return [TimeEntry(**t) for t in response['data']['rejectTimeEntries']]\n    \n    async def bulk_create(self, entries: List[Dict[str, Any]]) -> List[TimeEntry]:\n        \"\"\"Create multiple time entries at once\"\"\"\n        mutation = self._build_bulk_create_mutation(entries)\n        response = await self._execute(mutation)\n        return [TimeEntry(**t) for t in response['data']['bulkCreateTimeEntries']]\n    \n    async def get_summary(self, \n                         user_id: Optional[str] = None,\n                         start_date: datetime = None,\n                         end_date: datetime = None,\n                         group_by: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Get time entry summary/analytics\"\"\"\n        query = self._build_summary_query(user_id, start_date, end_date, group_by)\n        response = await self._execute(query)\n        return response['data']['timeEntrySummary']\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass TimeEntryType(str, Enum):\n    TICKET = \"ticket\"\n    TASK = \"task\"\n    PROJECT = \"project\"\n    GENERAL = \"general\"\n\nclass TimeEntryStatus(str, Enum):\n    DRAFT = \"draft\"\n    SUBMITTED = \"submitted\"\n    APPROVED = \"approved\"\n    REJECTED = \"rejected\"\n    INVOICED = \"invoiced\"\n\nclass TimeEntry:\n    id: str\n    user_id: str\n    entity_type: TimeEntryType\n    entity_id: Optional[str]\n    description: str\n    start_time: datetime\n    duration: timedelta\n    billable: bool\n    status: TimeEntryStatus\n    approval_notes: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_time_entries.py` that:\n1. Mock GraphQL responses for all CRUD operations\n2. Test time entry creation with required and optional fields\n3. Test time entry retrieval by ID\n4. Test time entry listing with various filters\n5. Test time entry updates\n6. Test time entry deletion\n7. Test approval workflow (submit, approve, reject)\n8. Test bulk operations\n9. Test time summary/analytics\n10. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GraphQL Query Builders for Time Entries",
            "description": "Create the GraphQL query and mutation builder methods for the TimeEntriesManager class to support all the required API operations.",
            "dependencies": [],
            "details": "Implement the following methods in the TimeEntriesManager class:\n\n1. `_build_get_query(time_entry_id)`: Build a GraphQL query to fetch a single time entry by ID\n2. `_build_list_query(user_id, entity_type, entity_id, start_date, end_date, billable, status)`: Build a GraphQL query with filters to list time entries\n3. `_build_create_mutation(data)`: Build a GraphQL mutation to create a new time entry\n4. `_build_update_mutation(time_entry_id, data)`: Build a GraphQL mutation to update an existing time entry\n5. `_build_delete_mutation(time_entry_id)`: Build a GraphQL mutation to delete a time entry\n6. `_build_submit_mutation(time_entry_ids)`: Build a GraphQL mutation to submit time entries for approval\n7. `_build_approve_mutation(time_entry_ids)`: Build a GraphQL mutation to approve time entries\n8. `_build_reject_mutation(time_entry_ids, reason)`: Build a GraphQL mutation to reject time entries\n9. `_build_bulk_create_mutation(entries)`: Build a GraphQL mutation to create multiple time entries\n10. `_build_summary_query(user_id, start_date, end_date, group_by)`: Build a GraphQL query to get time entry summaries",
            "status": "done",
            "testStrategy": "Create unit tests that verify each query builder method generates the correct GraphQL query structure with appropriate variables and fields."
          },
          {
            "id": 2,
            "title": "Complete TimeEntry Type Definition",
            "description": "Finalize the TimeEntry class in types.py with all required fields and methods for proper serialization and deserialization.",
            "dependencies": [],
            "details": "Enhance the TimeEntry class in types.py with:\n\n1. Complete the class definition with proper type annotations\n2. Add any missing fields based on the SuperOps API documentation\n3. Implement __init__ method to handle data conversion (e.g., parsing datetime strings)\n4. Add helper methods for common operations (e.g., calculating total hours)\n5. Add validation logic for field values\n6. Implement proper string representation (__str__ and __repr__)\n7. Add any necessary property methods for derived values\n\nEnsure the TimeEntryType and TimeEntryStatus enums are complete with all possible values from the API.",
            "status": "done",
            "testStrategy": "Create unit tests that verify TimeEntry objects can be properly created from API responses and that all fields are correctly typed and validated."
          },
          {
            "id": 3,
            "title": "Implement Time Entry CRUD Operations",
            "description": "Complete the implementation of the basic CRUD operations (get, list, create, update, delete) in the TimeEntriesManager class.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Finalize the implementation of the following methods in TimeEntriesManager:\n\n1. `get(time_entry_id)`: Fetch a time entry by ID, handle error cases\n2. `list(user_id, entity_type, entity_id, start_date, end_date, billable, status)`: List time entries with filters, implement pagination if needed\n3. `create(data)`: Create a new time entry with validation\n4. `update(time_entry_id, data)`: Update an existing time entry with validation\n5. `delete(time_entry_id)`: Delete a time entry and handle response\n\nEnsure proper error handling, input validation, and response parsing for each method.",
            "status": "done",
            "testStrategy": "Create unit tests that mock GraphQL responses and verify each CRUD operation correctly handles successful responses and error cases."
          },
          {
            "id": 4,
            "title": "Implement Time Entry Approval Workflow",
            "description": "Complete the implementation of the approval workflow methods (submit_for_approval, approve, reject) in the TimeEntriesManager class.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Finalize the implementation of the following methods in TimeEntriesManager:\n\n1. `submit_for_approval(time_entry_ids)`: Submit multiple time entries for approval\n2. `approve(time_entry_ids)`: Approve multiple time entries\n3. `reject(time_entry_ids, reason)`: Reject multiple time entries with a reason\n\nEnsure proper validation of inputs, handling of batch operations, and processing of responses. Add helper methods if needed to simplify common approval workflows.",
            "status": "done",
            "testStrategy": "Create unit tests that verify approval workflow methods correctly handle various scenarios including successful operations, partial successes, and failures."
          },
          {
            "id": 5,
            "title": "Implement Bulk Operations and Reporting Features",
            "description": "Complete the implementation of bulk operations and reporting features in the TimeEntriesManager class.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Finalize the implementation of the following methods in TimeEntriesManager:\n\n1. `bulk_create(entries)`: Create multiple time entries at once with proper validation\n2. `get_summary(user_id, start_date, end_date, group_by)`: Get time entry summaries with various grouping options\n\nAdd additional helper methods for common reporting needs:\n\n1. `get_billable_hours(user_id, start_date, end_date)`: Calculate total billable hours\n2. `get_time_by_entity(entity_type, entity_id, start_date, end_date)`: Get time entries for a specific entity\n3. `export_time_entries(format, filters)`: Export time entries in various formats (CSV, PDF, etc.)\n\nEnsure proper handling of large datasets and implement any necessary pagination or chunking for bulk operations.",
            "status": "done",
            "testStrategy": "Create unit tests that verify bulk operations handle large datasets correctly and that reporting methods return properly formatted data."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Enhanced Notes/Comments System",
        "description": "Create a CommentsManager class to provide a unified comment interface across all entities, with support for rich text, markdown, threading, visibility controls, and attachments.",
        "details": "Create a new file `comments.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import Comment, CommentVisibility, EntityType\n\nclass CommentsManager(BaseManager):\n    \"\"\"Manager for SuperOps Comments API operations\"\"\"\n    \n    async def get(self, comment_id: str) -> Comment:\n        \"\"\"Get a comment by ID\"\"\"\n        query = self._build_get_query(comment_id)\n        response = await self._execute(query)\n        return Comment(**response['data']['comment'])\n    \n    async def list(self, \n                   entity_type: EntityType,\n                   entity_id: str,\n                   visibility: Optional[CommentVisibility] = None,\n                   parent_id: Optional[str] = None) -> List[Comment]:\n        \"\"\"List comments for an entity with optional filtering\"\"\"\n        query = self._build_list_query(entity_type, entity_id, visibility, parent_id)\n        response = await self._execute(query)\n        return [Comment(**c) for c in response['data']['comments']]\n    \n    async def create(self, \n                     entity_type: EntityType,\n                     entity_id: str,\n                     content: str,\n                     visibility: CommentVisibility = CommentVisibility.INTERNAL,\n                     parent_id: Optional[str] = None,\n                     attachment_ids: Optional[List[str]] = None) -> Comment:\n        \"\"\"Create a new comment\"\"\"\n        data = {\n            \"entity_type\": entity_type,\n            \"entity_id\": entity_id,\n            \"content\": content,\n            \"visibility\": visibility\n        }\n        if parent_id:\n            data[\"parent_id\"] = parent_id\n        if attachment_ids:\n            data[\"attachment_ids\"] = attachment_ids\n            \n        mutation = self._build_create_mutation(data)\n        response = await self._execute(mutation)\n        return Comment(**response['data']['createComment'])\n    \n    async def update(self, comment_id: str, content: str) -> Comment:\n        \"\"\"Update an existing comment\"\"\"\n        mutation = self._build_update_mutation(comment_id, content)\n        response = await self._execute(mutation)\n        return Comment(**response['data']['updateComment'])\n    \n    async def delete(self, comment_id: str) -> bool:\n        \"\"\"Delete a comment\"\"\"\n        mutation = self._build_delete_mutation(comment_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteComment']['success']\n    \n    async def change_visibility(self, comment_id: str, visibility: CommentVisibility) -> Comment:\n        \"\"\"Change comment visibility\"\"\"\n        mutation = self._build_visibility_mutation(comment_id, visibility)\n        response = await self._execute(mutation)\n        return Comment(**response['data']['changeCommentVisibility'])\n    \n    async def add_attachment(self, comment_id: str, attachment_id: str) -> Comment:\n        \"\"\"Add an attachment to a comment\"\"\"\n        mutation = self._build_add_attachment_mutation(comment_id, attachment_id)\n        response = await self._execute(mutation)\n        return Comment(**response['data']['addCommentAttachment'])\n    \n    async def remove_attachment(self, comment_id: str, attachment_id: str) -> Comment:\n        \"\"\"Remove an attachment from a comment\"\"\"\n        mutation = self._build_remove_attachment_mutation(comment_id, attachment_id)\n        response = await self._execute(mutation)\n        return Comment(**response['data']['removeCommentAttachment'])\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass EntityType(str, Enum):\n    TICKET = \"ticket\"\n    TASK = \"task\"\n    PROJECT = \"project\"\n    CLIENT = \"client\"\n    ASSET = \"asset\"\n    CONTRACT = \"contract\"\n    # other entity types\n\nclass CommentVisibility(str, Enum):\n    INTERNAL = \"internal\"\n    CLIENT = \"client\"\n    PUBLIC = \"public\"\n\nclass Comment:\n    id: str\n    entity_type: EntityType\n    entity_id: str\n    content: str\n    author_id: str\n    visibility: CommentVisibility\n    parent_id: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n    attachment_ids: List[str]\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_comments.py` that:\n1. Mock GraphQL responses for all CRUD operations\n2. Test comment creation with required and optional fields\n3. Test comment retrieval by ID\n4. Test comment listing with various filters\n5. Test comment updates\n6. Test comment deletion\n7. Test comment visibility changes\n8. Test comment threading (parent-child relationships)\n9. Test attachment management\n10. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GraphQL Query Builders for Comments",
            "description": "Create the GraphQL query and mutation builder methods for the CommentsManager class to handle all CRUD operations for comments.",
            "dependencies": [],
            "details": "Implement the following methods in the CommentsManager class:\n\n1. `_build_get_query(comment_id)`: Build a GraphQL query to fetch a single comment by ID\n2. `_build_list_query(entity_type, entity_id, visibility, parent_id)`: Build a GraphQL query to list comments with filters\n3. `_build_create_mutation(data)`: Build a GraphQL mutation to create a new comment\n4. `_build_update_mutation(comment_id, content)`: Build a GraphQL mutation to update a comment\n5. `_build_delete_mutation(comment_id)`: Build a GraphQL mutation to delete a comment\n6. `_build_visibility_mutation(comment_id, visibility)`: Build a GraphQL mutation to change comment visibility\n7. `_build_add_attachment_mutation(comment_id, attachment_id)`: Build a GraphQL mutation to add an attachment\n8. `_build_remove_attachment_mutation(comment_id, attachment_id)`: Build a GraphQL mutation to remove an attachment\n\nEach method should return a properly formatted GraphQL query/mutation string.",
            "status": "pending",
            "testStrategy": "Create unit tests that verify each query builder generates the correct GraphQL syntax with proper variables and fields."
          },
          {
            "id": 2,
            "title": "Complete Type Definitions for Comments System",
            "description": "Enhance the type definitions in types.py to fully support the comments system, including proper Enum classes and the Comment data class.",
            "dependencies": [],
            "details": "In the types.py file:\n\n1. Complete the EntityType enum with all supported entity types\n2. Complete the CommentVisibility enum with all visibility options\n3. Implement the Comment class with proper type annotations for all fields\n4. Add any additional helper types needed for the comments system\n5. Ensure all types have proper docstrings explaining their purpose\n6. Add validation logic where appropriate (e.g., for enum values)\n\nMake sure all types are properly exported and available for import by the CommentsManager class.",
            "status": "pending",
            "testStrategy": "Create unit tests that verify the type definitions work correctly, including serialization/deserialization of Comment objects and validation of enum values."
          },
          {
            "id": 3,
            "title": "Implement Rich Text and Markdown Support",
            "description": "Add support for rich text and markdown formatting in comments, including proper content parsing and rendering.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "Enhance the CommentsManager class to support rich text and markdown:\n\n1. Add a `format` parameter to the create and update methods with options like 'plain', 'markdown', 'html'\n2. Implement content validation based on the format\n3. Add a `render_content(comment, format='html')` method that converts between formats\n4. Update the GraphQL query builders to include format information\n5. Add support for basic formatting operations (bold, italic, lists, etc.)\n6. Handle sanitization of user input to prevent XSS attacks\n\nConsider using a library like markdown2 or mistune for markdown parsing.",
            "status": "pending",
            "testStrategy": "Test markdown parsing and rendering with various input formats, ensuring proper conversion and sanitization of potentially dangerous content."
          },
          {
            "id": 4,
            "title": "Implement Comment Threading and Hierarchy",
            "description": "Enhance the CommentsManager to fully support threaded comments with proper parent-child relationships and hierarchical retrieval.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "Implement threading support in the CommentsManager:\n\n1. Enhance the `list` method to support retrieving full comment threads\n2. Add a `get_thread(comment_id)` method that returns a comment and all its replies\n3. Add a `get_thread_hierarchy(entity_type, entity_id)` method that returns comments in a hierarchical structure\n4. Implement proper validation when creating comments with parent_id\n5. Add support for thread-specific operations (e.g., collapsing/expanding threads)\n6. Handle deletion of comments with children (either cascade delete or orphan handling)\n\nEnsure the API maintains proper relationships between parent and child comments.",
            "status": "pending",
            "testStrategy": "Test the creation of nested comment threads, retrieval of hierarchical comments, and proper handling of parent-child relationships when updating or deleting comments."
          },
          {
            "id": 5,
            "title": "Implement Attachment Management for Comments",
            "description": "Complete the attachment handling functionality for comments, including adding and removing attachments from comments.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "Implement attachment support in the CommentsManager:\n\n1. Finalize the `add_attachment` and `remove_attachment` methods\n2. Add a `get_attachments(comment_id)` method to retrieve all attachments for a comment\n3. Implement batch operations for adding/removing multiple attachments\n4. Add validation for attachment types and sizes\n5. Implement proper error handling for attachment operations\n6. Update the Comment type to properly handle attachment metadata\n\nEnsure proper integration with the AttachmentsManager class that will be implemented in Task 6.",
            "status": "pending",
            "testStrategy": "Test adding and removing attachments from comments, including edge cases like invalid attachment IDs, duplicate attachments, and batch operations."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Attachments/File Management",
        "description": "Create an AttachmentsManager class to handle file uploads via REST endpoints, file attachment to any entity, file metadata management, bulk operations, and versioning support.",
        "details": "Create a new file `attachments.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union, BinaryIO\nfrom datetime import datetime\nimport os\nimport aiohttp\n\nfrom ..base import BaseManager\nfrom ..types import Attachment, EntityType\n\nclass AttachmentsManager(BaseManager):\n    \"\"\"Manager for SuperOps Attachments API operations\"\"\"\n    \n    async def get(self, attachment_id: str) -> Attachment:\n        \"\"\"Get attachment metadata by ID\"\"\"\n        query = self._build_get_query(attachment_id)\n        response = await self._execute(query)\n        return Attachment(**response['data']['attachment'])\n    \n    async def list(self, \n                   entity_type: EntityType,\n                   entity_id: str) -> List[Attachment]:\n        \"\"\"List attachments for an entity\"\"\"\n        query = self._build_list_query(entity_type, entity_id)\n        response = await self._execute(query)\n        return [Attachment(**a) for a in response['data']['attachments']]\n    \n    async def upload(self, \n                     file_path: str, \n                     entity_type: EntityType,\n                     entity_id: str,\n                     description: Optional[str] = None) -> Attachment:\n        \"\"\"Upload a file and attach it to an entity\"\"\"\n        # First get upload URL from GraphQL\n        mutation = self._build_get_upload_url_mutation(entity_type, entity_id, os.path.basename(file_path))\n        response = await self._execute(mutation)\n        upload_data = response['data']['getFileUploadUrl']\n        \n        # Upload file to REST endpoint\n        async with aiohttp.ClientSession() as session:\n            with open(file_path, 'rb') as f:\n                form_data = aiohttp.FormData()\n                form_data.add_field('file', \n                                   f,\n                                   filename=os.path.basename(file_path),\n                                   content_type='application/octet-stream')\n                \n                async with session.post(upload_data['url'], data=form_data, headers=upload_data['headers']) as resp:\n                    if resp.status != 200:\n                        error_text = await resp.text()\n                        raise Exception(f\"File upload failed: {error_text}\")\n        \n        # Complete the upload process via GraphQL\n        complete_mutation = self._build_complete_upload_mutation(\n            upload_data['token'],\n            entity_type,\n            entity_id,\n            description\n        )\n        complete_response = await self._execute(complete_mutation)\n        return Attachment(**complete_response['data']['completeFileUpload'])\n    \n    async def upload_content(self, \n                           content: BinaryIO,\n                           filename: str,\n                           entity_type: EntityType,\n                           entity_id: str,\n                           description: Optional[str] = None) -> Attachment:\n        \"\"\"Upload file content directly and attach it to an entity\"\"\"\n        # Similar to upload but accepts file content instead of path\n        # Implementation similar to above\n        pass\n    \n    async def download(self, attachment_id: str) -> bytes:\n        \"\"\"Download file content\"\"\"\n        query = self._build_download_query(attachment_id)\n        response = await self._execute(query)\n        download_url = response['data']['getFileDownloadUrl']['url']\n        \n        async with aiohttp.ClientSession() as session:\n            async with session.get(download_url) as resp:\n                if resp.status != 200:\n                    error_text = await resp.text()\n                    raise Exception(f\"File download failed: {error_text}\")\n                return await resp.read()\n    \n    async def delete(self, attachment_id: str) -> bool:\n        \"\"\"Delete an attachment\"\"\"\n        mutation = self._build_delete_mutation(attachment_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteAttachment']['success']\n    \n    async def update(self, attachment_id: str, description: str) -> Attachment:\n        \"\"\"Update attachment metadata\"\"\"\n        mutation = self._build_update_mutation(attachment_id, description)\n        response = await self._execute(mutation)\n        return Attachment(**response['data']['updateAttachment'])\n    \n    async def create_version(self, \n                           attachment_id: str,\n                           file_path: str) -> Attachment:\n        \"\"\"Create a new version of an existing attachment\"\"\"\n        # Implementation similar to upload but for versioning\n        pass\n    \n    async def bulk_upload(self, \n                         file_paths: List[str],\n                         entity_type: EntityType,\n                         entity_id: str) -> List[Attachment]:\n        \"\"\"Upload multiple files at once\"\"\"\n        # Implementation for bulk uploads\n        pass\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass Attachment:\n    id: str\n    filename: str\n    size: int\n    mime_type: str\n    description: Optional[str]\n    entity_type: EntityType\n    entity_id: str\n    version: int\n    created_at: datetime\n    updated_at: datetime\n    created_by: str\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_attachments.py` that:\n1. Mock GraphQL responses for metadata operations\n2. Mock REST API responses for file upload/download\n3. Test file upload with various file types and sizes\n4. Test attachment retrieval by ID\n5. Test attachment listing for entities\n6. Test attachment metadata updates\n7. Test attachment deletion\n8. Test file versioning\n9. Test bulk operations\n10. Test error handling for invalid inputs, API errors, and file errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Attachment Type and GraphQL Query Builders",
            "description": "Create the Attachment type class and implement the GraphQL query/mutation builders needed for the AttachmentsManager class.",
            "dependencies": [],
            "details": "1. Complete the Attachment class in types.py with all required fields\n2. Add EntityType enum if not already present\n3. Implement the following query/mutation builders in the AttachmentsManager class:\n   - _build_get_query(attachment_id)\n   - _build_list_query(entity_type, entity_id)\n   - _build_get_upload_url_mutation(entity_type, entity_id, filename)\n   - _build_complete_upload_mutation(token, entity_type, entity_id, description)\n   - _build_download_query(attachment_id)\n   - _build_delete_mutation(attachment_id)\n   - _build_update_mutation(attachment_id, description)",
            "status": "pending",
            "testStrategy": "Create unit tests that verify the structure of generated GraphQL queries/mutations matches the expected format required by the SuperOps API."
          },
          {
            "id": 2,
            "title": "Implement Basic Attachment Operations",
            "description": "Complete the core attachment operations: get, list, delete, and update methods in the AttachmentsManager class.",
            "dependencies": [
              "6.1"
            ],
            "details": "1. Finalize the implementation of the following methods:\n   - get(attachment_id): Retrieve attachment metadata by ID\n   - list(entity_type, entity_id): List all attachments for a specific entity\n   - delete(attachment_id): Delete an attachment\n   - update(attachment_id, description): Update attachment metadata\n2. Ensure proper error handling for API responses\n3. Add appropriate docstrings and type hints",
            "status": "pending",
            "testStrategy": "Create unit tests that mock GraphQL responses and verify each method correctly processes the response data and returns properly typed objects."
          },
          {
            "id": 3,
            "title": "Implement File Upload and Download Functionality",
            "description": "Complete the file upload and download functionality, including handling file content directly and via file paths.",
            "dependencies": [
              "6.1"
            ],
            "details": "1. Finalize the implementation of:\n   - upload(file_path, entity_type, entity_id, description): Upload a file from disk\n   - upload_content(content, filename, entity_type, entity_id, description): Upload file content directly\n   - download(attachment_id): Download file content\n2. Implement proper error handling for HTTP requests\n3. Handle content type detection\n4. Implement proper file streaming for large files\n5. Add appropriate progress tracking for large file uploads/downloads",
            "status": "pending",
            "testStrategy": "Create tests that mock both GraphQL and REST API responses to verify the upload and download processes work correctly with various file types and sizes."
          },
          {
            "id": 4,
            "title": "Implement Versioning Support",
            "description": "Implement the create_version method to support file versioning functionality.",
            "dependencies": [
              "6.3"
            ],
            "details": "1. Complete the implementation of create_version(attachment_id, file_path) method:\n   - Retrieve the existing attachment metadata\n   - Get upload URL for the new version\n   - Upload the file content\n   - Complete the version creation process\n2. Add appropriate error handling\n3. Ensure version numbers are properly incremented\n4. Add support for version comments/descriptions\n5. Consider implementing a get_versions(attachment_id) method to retrieve version history",
            "status": "pending",
            "testStrategy": "Create tests that verify versioning works correctly by uploading multiple versions of the same file and checking that version numbers increment properly."
          },
          {
            "id": 5,
            "title": "Implement Bulk Operations",
            "description": "Complete the bulk_upload method and add additional bulk operations for attachments.",
            "dependencies": [
              "6.3"
            ],
            "details": "1. Implement bulk_upload(file_paths, entity_type, entity_id) method:\n   - Process multiple files in parallel using asyncio.gather\n   - Provide progress tracking for multiple uploads\n   - Handle partial failures appropriately\n2. Add additional bulk operations:\n   - bulk_delete(attachment_ids): Delete multiple attachments\n   - bulk_download(attachment_ids, target_dir): Download multiple attachments\n3. Implement proper concurrency controls and rate limiting\n4. Add appropriate error aggregation and reporting",
            "status": "pending",
            "testStrategy": "Create tests that verify bulk operations work correctly with various numbers of files, including edge cases like empty lists and very large numbers of files."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement User Roles & Permissions API",
        "description": "Create a UsersManager class to handle user management and provisioning, role-based access control, custom role creation, permission granularity, and user group management.",
        "details": "Create a new file `users.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import User, Role, Permission, UserGroup\n\nclass UsersManager(BaseManager):\n    \"\"\"Manager for SuperOps Users API operations\"\"\"\n    \n    async def get_user(self, user_id: str) -> User:\n        \"\"\"Get a user by ID\"\"\"\n        query = self._build_get_user_query(user_id)\n        response = await self._execute(query)\n        return User(**response['data']['user'])\n    \n    async def list_users(self, \n                        role_id: Optional[str] = None,\n                        group_id: Optional[str] = None,\n                        active: Optional[bool] = None) -> List[User]:\n        \"\"\"List users with optional filtering\"\"\"\n        query = self._build_list_users_query(role_id, group_id, active)\n        response = await self._execute(query)\n        return [User(**u) for u in response['data']['users']]\n    \n    async def create_user(self, data: Dict[str, Any]) -> User:\n        \"\"\"Create a new user\"\"\"\n        mutation = self._build_create_user_mutation(data)\n        response = await self._execute(mutation)\n        return User(**response['data']['createUser'])\n    \n    async def update_user(self, user_id: str, data: Dict[str, Any]) -> User:\n        \"\"\"Update an existing user\"\"\"\n        mutation = self._build_update_user_mutation(user_id, data)\n        response = await self._execute(mutation)\n        return User(**response['data']['updateUser'])\n    \n    async def deactivate_user(self, user_id: str) -> User:\n        \"\"\"Deactivate a user\"\"\"\n        mutation = self._build_deactivate_user_mutation(user_id)\n        response = await self._execute(mutation)\n        return User(**response['data']['deactivateUser'])\n    \n    async def reactivate_user(self, user_id: str) -> User:\n        \"\"\"Reactivate a user\"\"\"\n        mutation = self._build_reactivate_user_mutation(user_id)\n        response = await self._execute(mutation)\n        return User(**response['data']['reactivateUser'])\n    \n    # Role management\n    async def get_role(self, role_id: str) -> Role:\n        \"\"\"Get a role by ID\"\"\"\n        query = self._build_get_role_query(role_id)\n        response = await self._execute(query)\n        return Role(**response['data']['role'])\n    \n    async def list_roles(self) -> List[Role]:\n        \"\"\"List all roles\"\"\"\n        query = self._build_list_roles_query()\n        response = await self._execute(query)\n        return [Role(**r) for r in response['data']['roles']]\n    \n    async def create_role(self, name: str, permissions: List[Permission]) -> Role:\n        \"\"\"Create a new role\"\"\"\n        mutation = self._build_create_role_mutation(name, permissions)\n        response = await self._execute(mutation)\n        return Role(**response['data']['createRole'])\n    \n    async def update_role(self, role_id: str, name: str, permissions: List[Permission]) -> Role:\n        \"\"\"Update an existing role\"\"\"\n        mutation = self._build_update_role_mutation(role_id, name, permissions)\n        response = await self._execute(mutation)\n        return Role(**response['data']['updateRole'])\n    \n    async def delete_role(self, role_id: str) -> bool:\n        \"\"\"Delete a role\"\"\"\n        mutation = self._build_delete_role_mutation(role_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteRole']['success']\n    \n    # User group management\n    async def get_group(self, group_id: str) -> UserGroup:\n        \"\"\"Get a user group by ID\"\"\"\n        query = self._build_get_group_query(group_id)\n        response = await self._execute(query)\n        return UserGroup(**response['data']['userGroup'])\n    \n    async def list_groups(self) -> List[UserGroup]:\n        \"\"\"List all user groups\"\"\"\n        query = self._build_list_groups_query()\n        response = await self._execute(query)\n        return [UserGroup(**g) for g in response['data']['userGroups']]\n    \n    async def create_group(self, name: str, user_ids: List[str] = None) -> UserGroup:\n        \"\"\"Create a new user group\"\"\"\n        mutation = self._build_create_group_mutation(name, user_ids or [])\n        response = await self._execute(mutation)\n        return UserGroup(**response['data']['createUserGroup'])\n    \n    async def update_group(self, group_id: str, name: str, user_ids: List[str]) -> UserGroup:\n        \"\"\"Update an existing user group\"\"\"\n        mutation = self._build_update_group_mutation(group_id, name, user_ids)\n        response = await self._execute(mutation)\n        return UserGroup(**response['data']['updateUserGroup'])\n    \n    async def delete_group(self, group_id: str) -> bool:\n        \"\"\"Delete a user group\"\"\"\n        mutation = self._build_delete_group_mutation(group_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteUserGroup']['success']\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass Permission(str, Enum):\n    # Client permissions\n    CLIENT_VIEW = \"client:view\"\n    CLIENT_CREATE = \"client:create\"\n    CLIENT_EDIT = \"client:edit\"\n    CLIENT_DELETE = \"client:delete\"\n    # Ticket permissions\n    TICKET_VIEW = \"ticket:view\"\n    TICKET_CREATE = \"ticket:create\"\n    TICKET_EDIT = \"ticket:edit\"\n    TICKET_DELETE = \"ticket:delete\"\n    # Add other permissions for all entities\n\nclass User:\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    role_id: str\n    active: bool\n    phone: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n    last_login: Optional[datetime]\n    group_ids: List[str]\n    # other fields\n\nclass Role:\n    id: str\n    name: str\n    permissions: List[Permission]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass UserGroup:\n    id: str\n    name: str\n    user_ids: List[str]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_users.py` that:\n1. Mock GraphQL responses for all operations\n2. Test user management (create, update, deactivate, reactivate)\n3. Test user retrieval and listing with filters\n4. Test role management (create, update, delete)\n5. Test role retrieval and listing\n6. Test user group management (create, update, delete)\n7. Test user group retrieval and listing\n8. Test permission assignment and validation\n9. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement User Management Query Builders",
            "description": "Create the GraphQL query builder methods for user management operations in the UsersManager class. This includes methods to build queries for retrieving and listing users with various filters.",
            "dependencies": [],
            "details": "Implement the following methods in the UsersManager class:\n\n1. `_build_get_user_query(user_id)`: Build a GraphQL query to fetch a user by ID with all relevant fields\n2. `_build_list_users_query(role_id, group_id, active)`: Build a GraphQL query to list users with optional filtering by role, group, and active status\n3. Include proper field selection for user objects (id, email, first_name, last_name, role_id, active, phone, created_at, updated_at, last_login, group_ids)\n4. Handle parameter validation and proper GraphQL syntax\n5. Ensure proper error handling for invalid parameters",
            "status": "pending",
            "testStrategy": "Create unit tests that verify:\n- The generated GraphQL queries have the correct structure\n- Filters are properly applied when parameters are provided\n- Field selection is comprehensive\n- Edge cases like empty parameters are handled correctly"
          },
          {
            "id": 2,
            "title": "Implement User Management Mutation Builders",
            "description": "Create the GraphQL mutation builder methods for user management operations in the UsersManager class. This includes methods to build mutations for creating, updating, deactivating, and reactivating users.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the following methods in the UsersManager class:\n\n1. `_build_create_user_mutation(data)`: Build a GraphQL mutation to create a new user with the provided data\n2. `_build_update_user_mutation(user_id, data)`: Build a GraphQL mutation to update an existing user\n3. `_build_deactivate_user_mutation(user_id)`: Build a GraphQL mutation to deactivate a user\n4. `_build_reactivate_user_mutation(user_id)`: Build a GraphQL mutation to reactivate a user\n5. Include proper input validation and error handling\n6. Ensure all required fields are included in the mutation variables",
            "status": "pending",
            "testStrategy": "Create unit tests that verify:\n- The generated GraphQL mutations have the correct structure\n- Input data is properly formatted and validated\n- Required fields are included\n- Error handling for invalid inputs"
          },
          {
            "id": 3,
            "title": "Implement Role Management Query/Mutation Builders",
            "description": "Create the GraphQL query and mutation builder methods for role management operations in the UsersManager class. This includes methods for retrieving, listing, creating, updating, and deleting roles.",
            "dependencies": [
              "7.2"
            ],
            "details": "Implement the following methods in the UsersManager class:\n\n1. `_build_get_role_query(role_id)`: Build a GraphQL query to fetch a role by ID\n2. `_build_list_roles_query()`: Build a GraphQL query to list all roles\n3. `_build_create_role_mutation(name, permissions)`: Build a GraphQL mutation to create a new role\n4. `_build_update_role_mutation(role_id, name, permissions)`: Build a GraphQL mutation to update an existing role\n5. `_build_delete_role_mutation(role_id)`: Build a GraphQL mutation to delete a role\n6. Ensure proper handling of permission enums in the mutations\n7. Include validation for role names and permission lists",
            "status": "pending",
            "testStrategy": "Create unit tests that verify:\n- The generated GraphQL queries and mutations have the correct structure\n- Permission enums are properly formatted in the mutations\n- Role data is properly validated\n- Error handling for invalid inputs"
          },
          {
            "id": 4,
            "title": "Implement User Group Management Query/Mutation Builders",
            "description": "Create the GraphQL query and mutation builder methods for user group management operations in the UsersManager class. This includes methods for retrieving, listing, creating, updating, and deleting user groups.",
            "dependencies": [
              "7.3"
            ],
            "details": "Implement the following methods in the UsersManager class:\n\n1. `_build_get_group_query(group_id)`: Build a GraphQL query to fetch a user group by ID\n2. `_build_list_groups_query()`: Build a GraphQL query to list all user groups\n3. `_build_create_group_mutation(name, user_ids)`: Build a GraphQL mutation to create a new user group\n4. `_build_update_group_mutation(group_id, name, user_ids)`: Build a GraphQL mutation to update an existing user group\n5. `_build_delete_group_mutation(group_id)`: Build a GraphQL mutation to delete a user group\n6. Include validation for group names and user ID lists\n7. Handle empty user ID lists appropriately",
            "status": "pending",
            "testStrategy": "Create unit tests that verify:\n- The generated GraphQL queries and mutations have the correct structure\n- User ID lists are properly formatted in the mutations\n- Group data is properly validated\n- Error handling for invalid inputs\n- Edge cases like empty user ID lists are handled correctly"
          },
          {
            "id": 5,
            "title": "Implement Integration Tests for UsersManager",
            "description": "Create comprehensive integration tests for the UsersManager class to ensure all user, role, and group management operations work correctly with the API.",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Create a test file `tests/test_users.py` that includes:\n\n1. Setup code to mock GraphQL responses for all operations\n2. Test cases for user management:\n   - Test creating users with various data combinations\n   - Test updating users with different field changes\n   - Test deactivating and reactivating users\n   - Test retrieving users by ID\n   - Test listing users with different filter combinations\n3. Test cases for role management:\n   - Test creating roles with different permission sets\n   - Test updating roles\n   - Test deleting roles\n   - Test retrieving and listing roles\n4. Test cases for user group management:\n   - Test creating groups with and without users\n   - Test updating groups (adding/removing users)\n   - Test deleting groups\n   - Test retrieving and listing groups\n5. Test error handling for all operations with invalid inputs",
            "status": "pending",
            "testStrategy": "Use pytest fixtures to set up mock responses for each API operation. Create parameterized tests to cover various input combinations. Verify that:\n- The manager correctly parses API responses into the appropriate objects\n- Error responses are properly handled and raised\n- All operations correctly build and execute the expected GraphQL queries/mutations\n- Edge cases and error conditions are properly tested"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Webhooks API",
        "description": "Create a WebhooksManager class to handle webhook subscription management, event filtering and routing, webhook authentication, retry logic, and testing utilities.",
        "details": "Create a new file `webhooks.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import Webhook, WebhookEvent\n\nclass WebhooksManager(BaseManager):\n    \"\"\"Manager for SuperOps Webhooks API operations\"\"\"\n    \n    async def get(self, webhook_id: str) -> Webhook:\n        \"\"\"Get a webhook by ID\"\"\"\n        query = self._build_get_query(webhook_id)\n        response = await self._execute(query)\n        return Webhook(**response['data']['webhook'])\n    \n    async def list(self, \n                   event_type: Optional[WebhookEvent] = None,\n                   active: Optional[bool] = None) -> List[Webhook]:\n        \"\"\"List webhooks with optional filtering\"\"\"\n        query = self._build_list_query(event_type, active)\n        response = await self._execute(query)\n        return [Webhook(**w) for w in response['data']['webhooks']]\n    \n    async def create(self, \n                     url: str,\n                     events: List[WebhookEvent],\n                     secret: Optional[str] = None,\n                     description: Optional[str] = None) -> Webhook:\n        \"\"\"Create a new webhook subscription\"\"\"\n        data = {\n            \"url\": url,\n            \"events\": events,\n        }\n        if secret:\n            data[\"secret\"] = secret\n        if description:\n            data[\"description\"] = description\n            \n        mutation = self._build_create_mutation(data)\n        response = await self._execute(mutation)\n        return Webhook(**response['data']['createWebhook'])\n    \n    async def update(self, \n                     webhook_id: str,\n                     url: Optional[str] = None,\n                     events: Optional[List[WebhookEvent]] = None,\n                     secret: Optional[str] = None,\n                     description: Optional[str] = None,\n                     active: Optional[bool] = None) -> Webhook:\n        \"\"\"Update an existing webhook\"\"\"\n        data = {}\n        if url is not None:\n            data[\"url\"] = url\n        if events is not None:\n            data[\"events\"] = events\n        if secret is not None:\n            data[\"secret\"] = secret\n        if description is not None:\n            data[\"description\"] = description\n        if active is not None:\n            data[\"active\"] = active\n            \n        mutation = self._build_update_mutation(webhook_id, data)\n        response = await self._execute(mutation)\n        return Webhook(**response['data']['updateWebhook'])\n    \n    async def delete(self, webhook_id: str) -> bool:\n        \"\"\"Delete a webhook\"\"\"\n        mutation = self._build_delete_mutation(webhook_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteWebhook']['success']\n    \n    async def test(self, webhook_id: str) -> Dict[str, Any]:\n        \"\"\"Test a webhook by sending a test event\"\"\"\n        mutation = self._build_test_mutation(webhook_id)\n        response = await self._execute(mutation)\n        return response['data']['testWebhook']\n    \n    async def get_delivery_history(self, \n                                  webhook_id: str,\n                                  limit: int = 10,\n                                  offset: int = 0) -> List[Dict[str, Any]]:\n        \"\"\"Get webhook delivery history\"\"\"\n        query = self._build_history_query(webhook_id, limit, offset)\n        response = await self._execute(query)\n        return response['data']['webhookDeliveryHistory']\n    \n    async def retry_delivery(self, delivery_id: str) -> Dict[str, Any]:\n        \"\"\"Retry a failed webhook delivery\"\"\"\n        mutation = self._build_retry_mutation(delivery_id)\n        response = await self._execute(mutation)\n        return response['data']['retryWebhookDelivery']\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass WebhookEvent(str, Enum):\n    # Client events\n    CLIENT_CREATED = \"client.created\"\n    CLIENT_UPDATED = \"client.updated\"\n    CLIENT_DELETED = \"client.deleted\"\n    # Ticket events\n    TICKET_CREATED = \"ticket.created\"\n    TICKET_UPDATED = \"ticket.updated\"\n    TICKET_DELETED = \"ticket.deleted\"\n    TICKET_STATUS_CHANGED = \"ticket.status_changed\"\n    # Add other events for all entities\n\nclass Webhook:\n    id: str\n    url: str\n    events: List[WebhookEvent]\n    secret: Optional[str]\n    description: Optional[str]\n    active: bool\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_webhooks.py` that:\n1. Mock GraphQL responses for all operations\n2. Test webhook creation with various configurations\n3. Test webhook retrieval by ID\n4. Test webhook listing with filters\n5. Test webhook updates\n6. Test webhook deletion\n7. Test webhook testing functionality\n8. Test delivery history retrieval\n9. Test retry functionality\n10. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GraphQL query builders for webhook operations",
            "description": "Create the GraphQL query and mutation builder methods for all webhook operations including get, list, create, update, delete, test, get_delivery_history, and retry_delivery.",
            "dependencies": [],
            "details": "Complete the implementation of the following methods in the WebhooksManager class:\n\n1. `_build_get_query(webhook_id)`: Build a GraphQL query to fetch a webhook by ID\n2. `_build_list_query(event_type, active)`: Build a GraphQL query to list webhooks with optional filters\n3. `_build_create_mutation(data)`: Build a GraphQL mutation to create a new webhook\n4. `_build_update_mutation(webhook_id, data)`: Build a GraphQL mutation to update an existing webhook\n5. `_build_delete_mutation(webhook_id)`: Build a GraphQL mutation to delete a webhook\n6. `_build_test_mutation(webhook_id)`: Build a GraphQL mutation to test a webhook\n7. `_build_history_query(webhook_id, limit, offset)`: Build a GraphQL query to get webhook delivery history\n8. `_build_retry_mutation(delivery_id)`: Build a GraphQL mutation to retry a failed webhook delivery\n\nEnsure each query/mutation includes all necessary fields for the corresponding return types.",
            "status": "pending",
            "testStrategy": "Create unit tests that verify each query builder generates the correct GraphQL query/mutation string with proper variables."
          },
          {
            "id": 2,
            "title": "Implement webhook authentication and signature verification",
            "description": "Add methods to generate and verify webhook signatures for secure webhook delivery, including HMAC-based signature generation and verification.",
            "dependencies": [
              "8.1"
            ],
            "details": "Add the following methods to the WebhooksManager class:\n\n1. `generate_signature(webhook_secret: str, payload: str) -> str`: Generate an HMAC-SHA256 signature for webhook payloads\n2. `verify_signature(webhook_secret: str, payload: str, signature: str) -> bool`: Verify that a received signature matches the expected signature\n3. `create_signed_headers(webhook_secret: str, payload: str) -> Dict[str, str]`: Create HTTP headers with signature for webhook requests\n\nImplement using Python's `hmac` and `hashlib` modules for secure signature generation. Include timestamp in the signature to prevent replay attacks.",
            "status": "pending",
            "testStrategy": "Test signature generation and verification with various payloads and secrets. Verify that signatures match when using the same secret and payload, and fail when using different values."
          },
          {
            "id": 3,
            "title": "Implement webhook event filtering and routing",
            "description": "Create utility methods to filter webhook events based on criteria and route them to appropriate handlers based on event type.",
            "dependencies": [
              "8.1"
            ],
            "details": "Add the following methods to the WebhooksManager class:\n\n1. `filter_events(events: List[Dict[str, Any]], event_type: Optional[WebhookEvent] = None, entity_id: Optional[str] = None) -> List[Dict[str, Any]]`: Filter webhook events based on event type and/or entity ID\n2. `get_subscribed_webhooks(event_type: WebhookEvent) -> List[Webhook]`: Get all active webhooks subscribed to a specific event type\n3. `route_event(event_type: WebhookEvent, payload: Dict[str, Any]) -> List[Dict[str, Any]]`: Route an event to all subscribed webhooks and return delivery attempts\n\nImplement efficient filtering logic that can handle large numbers of webhooks and events.",
            "status": "pending",
            "testStrategy": "Test event filtering with various combinations of event types and entity IDs. Test routing logic to ensure events are correctly sent to all subscribed webhooks."
          },
          {
            "id": 4,
            "title": "Implement webhook retry logic and delivery tracking",
            "description": "Add methods to handle webhook delivery failures, implement exponential backoff retry logic, and track delivery status.",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "Add the following methods to the WebhooksManager class:\n\n1. `_calculate_retry_delay(attempt: int) -> int`: Calculate delay for retry attempts using exponential backoff\n2. `_should_retry(status_code: int, attempt: int, max_attempts: int = 5) -> bool`: Determine if a failed webhook delivery should be retried\n3. `deliver_webhook(webhook: Webhook, event_type: WebhookEvent, payload: Dict[str, Any], attempt: int = 1) -> Dict[str, Any]`: Deliver a webhook with retry logic\n4. `track_delivery(webhook_id: str, event_type: WebhookEvent, payload: Dict[str, Any], response: Dict[str, Any]) -> Dict[str, Any]`: Record webhook delivery attempt and status\n\nImplement proper error handling and logging for webhook delivery attempts.",
            "status": "pending",
            "testStrategy": "Test retry logic with simulated failures at different status codes. Verify exponential backoff timing. Test delivery tracking to ensure all attempts are properly recorded."
          },
          {
            "id": 5,
            "title": "Create webhook testing utilities and documentation",
            "description": "Implement utilities for testing webhook integrations, including webhook simulation, payload validation, and comprehensive documentation.",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3",
              "8.4"
            ],
            "details": "Add the following methods and features to the WebhooksManager class:\n\n1. `simulate_webhook(event_type: WebhookEvent, entity_id: str, custom_payload: Optional[Dict[str, Any]] = None) -> Dict[str, Any]`: Generate a sample webhook payload for testing\n2. `validate_webhook_url(url: str) -> bool`: Validate that a webhook URL is properly formatted and accessible\n3. `get_webhook_event_schema(event_type: WebhookEvent) -> Dict[str, Any]`: Return the JSON schema for a specific webhook event type\n4. Add comprehensive docstrings to all webhook methods with examples\n5. Create a webhook security best practices guide as a class-level docstring\n\nImplement payload validation using JSON Schema to ensure webhook payloads match expected formats.",
            "status": "pending",
            "testStrategy": "Test webhook simulation with various event types. Test URL validation with valid and invalid URLs. Verify that generated payloads match the expected schema for each event type."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Configuration Management APIs",
        "description": "Create a ConfigManager class to handle categories/types for tickets, tasks, projects, custom priority schemes, custom status workflows, business rules, and custom field definitions.",
        "details": "Create a new file `config.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import (\n    CategoryType, \n    Category, \n    PriorityScheme, \n    StatusWorkflow, \n    BusinessRule, \n    CustomField,\n    EntityType\n)\n\nclass ConfigManager(BaseManager):\n    \"\"\"Manager for SuperOps Configuration API operations\"\"\"\n    \n    # Category management\n    async def get_category(self, category_id: str) -> Category:\n        \"\"\"Get a category by ID\"\"\"\n        query = self._build_get_category_query(category_id)\n        response = await self._execute(query)\n        return Category(**response['data']['category'])\n    \n    async def list_categories(self, \n                             entity_type: EntityType,\n                             category_type: Optional[CategoryType] = None) -> List[Category]:\n        \"\"\"List categories with optional filtering\"\"\"\n        query = self._build_list_categories_query(entity_type, category_type)\n        response = await self._execute(query)\n        return [Category(**c) for c in response['data']['categories']]\n    \n    async def create_category(self, \n                            name: str,\n                            entity_type: EntityType,\n                            category_type: CategoryType,\n                            description: Optional[str] = None) -> Category:\n        \"\"\"Create a new category\"\"\"\n        data = {\n            \"name\": name,\n            \"entity_type\": entity_type,\n            \"category_type\": category_type\n        }\n        if description:\n            data[\"description\"] = description\n            \n        mutation = self._build_create_category_mutation(data)\n        response = await self._execute(mutation)\n        return Category(**response['data']['createCategory'])\n    \n    async def update_category(self, \n                            category_id: str,\n                            name: Optional[str] = None,\n                            description: Optional[str] = None) -> Category:\n        \"\"\"Update an existing category\"\"\"\n        data = {}\n        if name is not None:\n            data[\"name\"] = name\n        if description is not None:\n            data[\"description\"] = description\n            \n        mutation = self._build_update_category_mutation(category_id, data)\n        response = await self._execute(mutation)\n        return Category(**response['data']['updateCategory'])\n    \n    async def delete_category(self, category_id: str) -> bool:\n        \"\"\"Delete a category\"\"\"\n        mutation = self._build_delete_category_mutation(category_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteCategory']['success']\n    \n    # Priority scheme management\n    async def get_priority_scheme(self, scheme_id: str) -> PriorityScheme:\n        \"\"\"Get a priority scheme by ID\"\"\"\n        query = self._build_get_priority_scheme_query(scheme_id)\n        response = await self._execute(query)\n        return PriorityScheme(**response['data']['priorityScheme'])\n    \n    async def list_priority_schemes(self, entity_type: Optional[EntityType] = None) -> List[PriorityScheme]:\n        \"\"\"List priority schemes with optional filtering\"\"\"\n        query = self._build_list_priority_schemes_query(entity_type)\n        response = await self._execute(query)\n        return [PriorityScheme(**p) for p in response['data']['prioritySchemes']]\n    \n    async def create_priority_scheme(self, \n                                   name: str,\n                                   entity_type: EntityType,\n                                   priorities: List[Dict[str, Any]]) -> PriorityScheme:\n        \"\"\"Create a new priority scheme\"\"\"\n        data = {\n            \"name\": name,\n            \"entity_type\": entity_type,\n            \"priorities\": priorities\n        }\n        mutation = self._build_create_priority_scheme_mutation(data)\n        response = await self._execute(mutation)\n        return PriorityScheme(**response['data']['createPriorityScheme'])\n    \n    # Status workflow management\n    async def get_status_workflow(self, workflow_id: str) -> StatusWorkflow:\n        \"\"\"Get a status workflow by ID\"\"\"\n        query = self._build_get_status_workflow_query(workflow_id)\n        response = await self._execute(query)\n        return StatusWorkflow(**response['data']['statusWorkflow'])\n    \n    async def list_status_workflows(self, entity_type: Optional[EntityType] = None) -> List[StatusWorkflow]:\n        \"\"\"List status workflows with optional filtering\"\"\"\n        query = self._build_list_status_workflows_query(entity_type)\n        response = await self._execute(query)\n        return [StatusWorkflow(**w) for w in response['data']['statusWorkflows']]\n    \n    async def create_status_workflow(self, \n                                   name: str,\n                                   entity_type: EntityType,\n                                   statuses: List[Dict[str, Any]],\n                                   transitions: List[Dict[str, Any]]) -> StatusWorkflow:\n        \"\"\"Create a new status workflow\"\"\"\n        data = {\n            \"name\": name,\n            \"entity_type\": entity_type,\n            \"statuses\": statuses,\n            \"transitions\": transitions\n        }\n        mutation = self._build_create_status_workflow_mutation(data)\n        response = await self._execute(mutation)\n        return StatusWorkflow(**response['data']['createStatusWorkflow'])\n    \n    # Business rule management\n    # Custom field management\n    # Implement other configuration management methods\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass CategoryType(str, Enum):\n    TYPE = \"type\"\n    SUBTYPE = \"subtype\"\n    CATEGORY = \"category\"\n    SUBCATEGORY = \"subcategory\"\n\nclass Category:\n    id: str\n    name: str\n    description: Optional[str]\n    entity_type: EntityType\n    category_type: CategoryType\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass PriorityScheme:\n    id: str\n    name: str\n    entity_type: EntityType\n    priorities: List[Dict[str, Any]]  # Complex structure with name, color, order, etc.\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass StatusWorkflow:\n    id: str\n    name: str\n    entity_type: EntityType\n    statuses: List[Dict[str, Any]]  # Complex structure with name, color, order, etc.\n    transitions: List[Dict[str, Any]]  # Complex structure with from_status, to_status, conditions, etc.\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass BusinessRule:\n    id: str\n    name: str\n    description: Optional[str]\n    entity_type: EntityType\n    conditions: List[Dict[str, Any]]\n    actions: List[Dict[str, Any]]\n    active: bool\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass CustomFieldType(str, Enum):\n    TEXT = \"text\"\n    NUMBER = \"number\"\n    DATE = \"date\"\n    DROPDOWN = \"dropdown\"\n    MULTISELECT = \"multiselect\"\n    CHECKBOX = \"checkbox\"\n    # other field types\n\nclass CustomField:\n    id: str\n    name: str\n    description: Optional[str]\n    entity_type: EntityType\n    field_type: CustomFieldType\n    required: bool\n    options: Optional[List[str]]  # For dropdown and multiselect\n    default_value: Optional[Any]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_config.py` that:\n1. Mock GraphQL responses for all operations\n2. Test category management (create, update, delete)\n3. Test category retrieval and listing with filters\n4. Test priority scheme management\n5. Test status workflow management\n6. Test business rule management\n7. Test custom field management\n8. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Category Management Methods and Query Builders",
            "description": "Complete the implementation of category management methods in the ConfigManager class, including the query and mutation builders for category operations.",
            "dependencies": [],
            "details": "1. Implement the missing query/mutation builder methods for categories:\n   - _build_get_category_query(category_id)\n   - _build_list_categories_query(entity_type, category_type)\n   - _build_create_category_mutation(data)\n   - _build_update_category_mutation(category_id, data)\n   - _build_delete_category_mutation(category_id)\n\n2. Each builder should construct the appropriate GraphQL query or mutation string with variables.\n\n3. Ensure proper error handling and validation in the category management methods.\n\n4. Complete the Category class implementation in types.py with all required fields and methods.",
            "status": "pending",
            "testStrategy": "Create unit tests that mock GraphQL responses for category operations. Test each category management method (get, list, create, update, delete) with various inputs and edge cases."
          },
          {
            "id": 2,
            "title": "Implement Priority Scheme Management Methods and Query Builders",
            "description": "Complete the implementation of priority scheme management methods in the ConfigManager class, including the query and mutation builders for priority scheme operations.",
            "dependencies": [
              "9.1"
            ],
            "details": "1. Implement the missing query/mutation builder methods for priority schemes:\n   - _build_get_priority_scheme_query(scheme_id)\n   - _build_list_priority_schemes_query(entity_type)\n   - _build_create_priority_scheme_mutation(data)\n   - _build_update_priority_scheme_mutation(scheme_id, data)\n   - _build_delete_priority_scheme_mutation(scheme_id)\n\n2. Add the missing methods to the ConfigManager class:\n   - update_priority_scheme(scheme_id, name, entity_type, priorities)\n   - delete_priority_scheme(scheme_id)\n\n3. Ensure proper validation of priority data structures in the create and update methods.\n\n4. Complete the PriorityScheme class implementation in types.py with all required fields and methods.",
            "status": "pending",
            "testStrategy": "Create unit tests that mock GraphQL responses for priority scheme operations. Test each priority scheme management method with various inputs, including complex priority configurations and edge cases."
          },
          {
            "id": 3,
            "title": "Implement Status Workflow Management Methods and Query Builders",
            "description": "Complete the implementation of status workflow management methods in the ConfigManager class, including the query and mutation builders for status workflow operations.",
            "dependencies": [
              "9.2"
            ],
            "details": "1. Implement the missing query/mutation builder methods for status workflows:\n   - _build_get_status_workflow_query(workflow_id)\n   - _build_list_status_workflows_query(entity_type)\n   - _build_create_status_workflow_mutation(data)\n   - _build_update_status_workflow_mutation(workflow_id, data)\n   - _build_delete_status_workflow_mutation(workflow_id)\n\n2. Add the missing methods to the ConfigManager class:\n   - update_status_workflow(workflow_id, name, entity_type, statuses, transitions)\n   - delete_status_workflow(workflow_id)\n\n3. Implement validation logic for status and transition data structures.\n\n4. Complete the StatusWorkflow class implementation in types.py with all required fields and methods.",
            "status": "pending",
            "testStrategy": "Create unit tests that mock GraphQL responses for status workflow operations. Test each status workflow management method with various inputs, including complex status and transition configurations."
          },
          {
            "id": 4,
            "title": "Implement Business Rule Management Methods",
            "description": "Implement the business rule management methods in the ConfigManager class, including CRUD operations and query/mutation builders for business rules.",
            "dependencies": [
              "9.3"
            ],
            "details": "1. Implement the following business rule management methods in the ConfigManager class:\n   - get_business_rule(rule_id)\n   - list_business_rules(entity_type)\n   - create_business_rule(name, entity_type, conditions, actions, description, active)\n   - update_business_rule(rule_id, name, conditions, actions, description, active)\n   - delete_business_rule(rule_id)\n   - activate_business_rule(rule_id)\n   - deactivate_business_rule(rule_id)\n\n2. Implement the corresponding query/mutation builder methods:\n   - _build_get_business_rule_query(rule_id)\n   - _build_list_business_rules_query(entity_type)\n   - _build_create_business_rule_mutation(data)\n   - _build_update_business_rule_mutation(rule_id, data)\n   - _build_delete_business_rule_mutation(rule_id)\n   - _build_activate_business_rule_mutation(rule_id)\n   - _build_deactivate_business_rule_mutation(rule_id)\n\n3. Complete the BusinessRule class implementation in types.py with all required fields and methods.",
            "status": "pending",
            "testStrategy": "Create unit tests that mock GraphQL responses for business rule operations. Test each business rule management method with various inputs, including complex condition and action configurations."
          },
          {
            "id": 5,
            "title": "Implement Custom Field Management Methods",
            "description": "Implement the custom field management methods in the ConfigManager class, including CRUD operations and query/mutation builders for custom fields.",
            "dependencies": [
              "9.4"
            ],
            "details": "1. Implement the following custom field management methods in the ConfigManager class:\n   - get_custom_field(field_id)\n   - list_custom_fields(entity_type, field_type)\n   - create_custom_field(name, entity_type, field_type, required, options, default_value, description)\n   - update_custom_field(field_id, name, required, options, default_value, description)\n   - delete_custom_field(field_id)\n\n2. Implement the corresponding query/mutation builder methods:\n   - _build_get_custom_field_query(field_id)\n   - _build_list_custom_fields_query(entity_type, field_type)\n   - _build_create_custom_field_mutation(data)\n   - _build_update_custom_field_mutation(field_id, data)\n   - _build_delete_custom_field_mutation(field_id)\n\n3. Implement validation logic for different field types (text, number, date, dropdown, etc.).\n\n4. Complete the CustomField class implementation in types.py with all required fields and methods.",
            "status": "pending",
            "testStrategy": "Create unit tests that mock GraphQL responses for custom field operations. Test each custom field management method with various inputs, including different field types and configurations."
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Reports API",
        "description": "Create a ReportsManager class to handle report generation and scheduling, custom report builders, report export formats, caching, optimization, and dashboard integration.",
        "details": "Create a new file `reports.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import Report, ReportType, ReportFormat, ReportSchedule\n\nclass ReportsManager(BaseManager):\n    \"\"\"Manager for SuperOps Reports API operations\"\"\"\n    \n    async def get(self, report_id: str) -> Report:\n        \"\"\"Get a report by ID\"\"\"\n        query = self._build_get_query(report_id)\n        response = await self._execute(query)\n        return Report(**response['data']['report'])\n    \n    async def list(self, \n                   report_type: Optional[ReportType] = None,\n                   created_by: Optional[str] = None) -> List[Report]:\n        \"\"\"List reports with optional filtering\"\"\"\n        query = self._build_list_query(report_type, created_by)\n        response = await self._execute(query)\n        return [Report(**r) for r in response['data']['reports']]\n    \n    async def create(self, \n                     name: str,\n                     report_type: ReportType,\n                     parameters: Dict[str, Any],\n                     description: Optional[str] = None) -> Report:\n        \"\"\"Create a new report\"\"\"\n        data = {\n            \"name\": name,\n            \"report_type\": report_type,\n            \"parameters\": parameters\n        }\n        if description:\n            data[\"description\"] = description\n            \n        mutation = self._build_create_mutation(data)\n        response = await self._execute(mutation)\n        return Report(**response['data']['createReport'])\n    \n    async def update(self, \n                     report_id: str,\n                     name: Optional[str] = None,\n                     parameters: Optional[Dict[str, Any]] = None,\n                     description: Optional[str] = None) -> Report:\n        \"\"\"Update an existing report\"\"\"\n        data = {}\n        if name is not None:\n            data[\"name\"] = name\n        if parameters is not None:\n            data[\"parameters\"] = parameters\n        if description is not None:\n            data[\"description\"] = description\n            \n        mutation = self._build_update_mutation(report_id, data)\n        response = await self._execute(mutation)\n        return Report(**response['data']['updateReport'])\n    \n    async def delete(self, report_id: str) -> bool:\n        \"\"\"Delete a report\"\"\"\n        mutation = self._build_delete_mutation(report_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteReport']['success']\n    \n    async def run(self, \n                 report_id: str,\n                 parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Run a report and get results\"\"\"\n        mutation = self._build_run_mutation(report_id, parameters)\n        response = await self._execute(mutation)\n        return response['data']['runReport']\n    \n    async def export(self, \n                    report_id: str,\n                    format: ReportFormat,\n                    parameters: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"Export a report in specified format and get download URL\"\"\"\n        mutation = self._build_export_mutation(report_id, format, parameters)\n        response = await self._execute(mutation)\n        return response['data']['exportReport']['download_url']\n    \n    async def schedule(self, \n                      report_id: str,\n                      schedule: ReportSchedule) -> Report:\n        \"\"\"Schedule a report to run automatically\"\"\"\n        mutation = self._build_schedule_mutation(report_id, schedule)\n        response = await self._execute(mutation)\n        return Report(**response['data']['scheduleReport'])\n    \n    async def get_dashboard_reports(self) -> List[Report]:\n        \"\"\"Get reports configured for dashboard display\"\"\"\n        query = self._build_dashboard_query()\n        response = await self._execute(query)\n        return [Report(**r) for r in response['data']['dashboardReports']]\n    \n    async def add_to_dashboard(self, report_id: str, position: Dict[str, Any]) -> bool:\n        \"\"\"Add a report to dashboard\"\"\"\n        mutation = self._build_add_to_dashboard_mutation(report_id, position)\n        response = await self._execute(mutation)\n        return response['data']['addReportToDashboard']['success']\n    \n    async def remove_from_dashboard(self, report_id: str) -> bool:\n        \"\"\"Remove a report from dashboard\"\"\"\n        mutation = self._build_remove_from_dashboard_mutation(report_id)\n        response = await self._execute(mutation)\n        return response['data']['removeReportFromDashboard']['success']\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass ReportType(str, Enum):\n    TICKET = \"ticket\"\n    CLIENT = \"client\"\n    ASSET = \"asset\"\n    PROJECT = \"project\"\n    TASK = \"task\"\n    TIME = \"time\"\n    BILLING = \"billing\"\n    USER = \"user\"\n    # other report types\n\nclass ReportFormat(str, Enum):\n    PDF = \"pdf\"\n    CSV = \"csv\"\n    EXCEL = \"excel\"\n    JSON = \"json\"\n\nclass ReportScheduleFrequency(str, Enum):\n    DAILY = \"daily\"\n    WEEKLY = \"weekly\"\n    MONTHLY = \"monthly\"\n\nclass ReportSchedule:\n    frequency: ReportScheduleFrequency\n    day_of_week: Optional[int]  # 0-6, for weekly\n    day_of_month: Optional[int]  # 1-31, for monthly\n    time: str  # HH:MM format\n    recipients: List[str]  # email addresses\n    format: ReportFormat\n    # other fields\n\nclass Report:\n    id: str\n    name: str\n    description: Optional[str]\n    report_type: ReportType\n    parameters: Dict[str, Any]\n    created_by: str\n    created_at: datetime\n    updated_at: datetime\n    last_run_at: Optional[datetime]\n    schedule: Optional[ReportSchedule]\n    on_dashboard: bool\n    dashboard_position: Optional[Dict[str, Any]]\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_reports.py` that:\n1. Mock GraphQL responses for all operations\n2. Test report creation with various configurations\n3. Test report retrieval by ID\n4. Test report listing with filters\n5. Test report updates\n6. Test report deletion\n7. Test report running with parameters\n8. Test report export in different formats\n9. Test report scheduling\n10. Test dashboard integration\n11. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GraphQL query builders for report operations",
            "description": "Create the GraphQL query and mutation builder methods for all report operations in the ReportsManager class. This includes methods for fetching, listing, creating, updating, and deleting reports.",
            "dependencies": [],
            "details": "Implement the following methods in the ReportsManager class:\n\n1. `_build_get_query(report_id)`: Build GraphQL query to fetch a single report by ID\n2. `_build_list_query(report_type, created_by)`: Build GraphQL query to list reports with optional filters\n3. `_build_create_mutation(data)`: Build GraphQL mutation to create a new report\n4. `_build_update_mutation(report_id, data)`: Build GraphQL mutation to update an existing report\n5. `_build_delete_mutation(report_id)`: Build GraphQL mutation to delete a report\n6. `_build_run_mutation(report_id, parameters)`: Build GraphQL mutation to run a report\n7. `_build_export_mutation(report_id, format, parameters)`: Build GraphQL mutation to export a report\n\nEach method should return a properly formatted GraphQL query/mutation string with variables.",
            "status": "pending",
            "testStrategy": "Create unit tests that verify each query builder generates the correct GraphQL syntax and includes all required variables. Test with various input combinations to ensure proper parameter handling."
          },
          {
            "id": 2,
            "title": "Implement report scheduling and dashboard integration",
            "description": "Complete the implementation of report scheduling and dashboard integration functionality in the ReportsManager class.",
            "dependencies": [
              "10.1"
            ],
            "details": "Implement the following methods in the ReportsManager class:\n\n1. `_build_schedule_mutation(report_id, schedule)`: Build GraphQL mutation to schedule a report\n2. `_build_dashboard_query()`: Build GraphQL query to fetch dashboard reports\n3. `_build_add_to_dashboard_mutation(report_id, position)`: Build GraphQL mutation to add a report to dashboard\n4. `_build_remove_from_dashboard_mutation(report_id)`: Build GraphQL mutation to remove a report from dashboard\n\nEnsure the schedule method properly validates the ReportSchedule object before sending the request. The dashboard position should handle coordinates for proper placement on the dashboard UI.",
            "status": "pending",
            "testStrategy": "Test scheduling with various frequency options (daily, weekly, monthly). Verify dashboard operations correctly position reports and handle updates to existing dashboard layouts."
          },
          {
            "id": 3,
            "title": "Implement report caching and optimization",
            "description": "Add caching capabilities to the ReportsManager to improve performance for frequently accessed reports and implement optimization strategies.",
            "dependencies": [
              "10.1"
            ],
            "details": "Enhance the ReportsManager class with the following features:\n\n1. Add a cache mechanism for storing report results with configurable TTL\n2. Implement a `get_cached` method that retrieves a report from cache if available\n3. Add a `clear_cache` method to invalidate cached reports\n4. Implement query optimization for large reports by adding pagination support\n5. Add a `_optimize_query` helper method that can modify queries based on report size and complexity\n\nThe caching system should use an in-memory store with optional persistence. Cache keys should be based on report ID and parameter hash to ensure uniqueness.",
            "status": "pending",
            "testStrategy": "Test cache hit/miss scenarios, cache invalidation, and performance improvements. Verify that large reports are properly paginated and optimized queries reduce response times."
          },
          {
            "id": 4,
            "title": "Implement custom report builders",
            "description": "Create a system for custom report builders that can generate specialized reports beyond the standard types.",
            "dependencies": [
              "10.1"
            ],
            "details": "Extend the ReportsManager with custom report building capabilities:\n\n1. Create a `ReportBuilder` base class that defines the interface for custom report builders\n2. Implement several concrete builder classes for common report types (e.g., `TicketReportBuilder`, `BillingReportBuilder`)\n3. Add a `build_custom_report` method to ReportsManager that accepts a builder instance and parameters\n4. Implement helper methods for common report customizations (filtering, grouping, aggregation)\n5. Add support for report templates that can be reused and customized\n\nThe builder pattern should allow for fluent chaining of configuration methods and produce a properly formatted report definition that can be passed to the create method.",
            "status": "pending",
            "testStrategy": "Test each builder with various configurations to ensure they generate valid report definitions. Verify that the custom reports can be created, run, and exported correctly."
          },
          {
            "id": 5,
            "title": "Implement comprehensive error handling and validation",
            "description": "Add robust error handling and input validation to all ReportsManager methods to ensure reliable operation and helpful error messages.",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3",
              "10.4"
            ],
            "details": "Enhance the ReportsManager with comprehensive error handling and validation:\n\n1. Implement parameter validation for all public methods\n2. Create custom exception classes for different error scenarios (e.g., `ReportNotFoundError`, `InvalidReportParametersError`)\n3. Add detailed error messages that provide actionable information\n4. Implement retry logic for transient failures when running or exporting reports\n5. Add logging throughout the class to capture operation details and errors\n6. Create a validation method for each report type to ensure parameters meet requirements\n\nAll validation should happen before sending requests to the API to prevent unnecessary network calls. Error messages should be user-friendly and suggest possible solutions.",
            "status": "pending",
            "testStrategy": "Test error scenarios including invalid inputs, missing reports, server errors, and validation failures. Verify that appropriate exceptions are raised with helpful messages. Test retry logic with simulated transient failures."
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement Billing & Invoicing API",
        "description": "Create a BillingManager class to handle invoice generation from time entries, billing rate management, invoice approval workflows, payment tracking, and recurring billing setup.",
        "details": "Create a new file `billing.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import Invoice, InvoiceStatus, BillingRate, Payment, RecurringBilling\n\nclass BillingManager(BaseManager):\n    \"\"\"Manager for SuperOps Billing & Invoicing API operations\"\"\"\n    \n    # Invoice management\n    async def get_invoice(self, invoice_id: str) -> Invoice:\n        \"\"\"Get an invoice by ID\"\"\"\n        query = self._build_get_invoice_query(invoice_id)\n        response = await self._execute(query)\n        return Invoice(**response['data']['invoice'])\n    \n    async def list_invoices(self, \n                           client_id: Optional[str] = None,\n                           status: Optional[InvoiceStatus] = None,\n                           start_date: Optional[datetime] = None,\n                           end_date: Optional[datetime] = None) -> List[Invoice]:\n        \"\"\"List invoices with optional filtering\"\"\"\n        query = self._build_list_invoices_query(client_id, status, start_date, end_date)\n        response = await self._execute(query)\n        return [Invoice(**i) for i in response['data']['invoices']]\n    \n    async def create_invoice(self, \n                           client_id: str,\n                           items: List[Dict[str, Any]],\n                           due_date: datetime,\n                           notes: Optional[str] = None) -> Invoice:\n        \"\"\"Create a new invoice\"\"\"\n        data = {\n            \"client_id\": client_id,\n            \"items\": items,\n            \"due_date\": due_date\n        }\n        if notes:\n            data[\"notes\"] = notes\n            \n        mutation = self._build_create_invoice_mutation(data)\n        response = await self._execute(mutation)\n        return Invoice(**response['data']['createInvoice'])\n    \n    async def update_invoice(self, \n                           invoice_id: str,\n                           items: Optional[List[Dict[str, Any]]] = None,\n                           due_date: Optional[datetime] = None,\n                           notes: Optional[str] = None) -> Invoice:\n        \"\"\"Update an existing invoice\"\"\"\n        data = {}\n        if items is not None:\n            data[\"items\"] = items\n        if due_date is not None:\n            data[\"due_date\"] = due_date\n        if notes is not None:\n            data[\"notes\"] = notes\n            \n        mutation = self._build_update_invoice_mutation(invoice_id, data)\n        response = await self._execute(mutation)\n        return Invoice(**response['data']['updateInvoice'])\n    \n    async def delete_invoice(self, invoice_id: str) -> bool:\n        \"\"\"Delete an invoice\"\"\"\n        mutation = self._build_delete_invoice_mutation(invoice_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteInvoice']['success']\n    \n    async def generate_from_time_entries(self, \n                                       client_id: str,\n                                       time_entry_ids: List[str],\n                                       due_date: datetime,\n                                       notes: Optional[str] = None) -> Invoice:\n        \"\"\"Generate an invoice from time entries\"\"\"\n        data = {\n            \"client_id\": client_id,\n            \"time_entry_ids\": time_entry_ids,\n            \"due_date\": due_date\n        }\n        if notes:\n            data[\"notes\"] = notes\n            \n        mutation = self._build_generate_invoice_mutation(data)\n        response = await self._execute(mutation)\n        return Invoice(**response['data']['generateInvoiceFromTimeEntries'])\n    \n    async def send_invoice(self, invoice_id: str, email: str) -> bool:\n        \"\"\"Send an invoice via email\"\"\"\n        mutation = self._build_send_invoice_mutation(invoice_id, email)\n        response = await self._execute(mutation)\n        return response['data']['sendInvoice']['success']\n    \n    # Billing rate management\n    async def get_billing_rate(self, rate_id: str) -> BillingRate:\n        \"\"\"Get a billing rate by ID\"\"\"\n        query = self._build_get_billing_rate_query(rate_id)\n        response = await self._execute(query)\n        return BillingRate(**response['data']['billingRate'])\n    \n    async def list_billing_rates(self, client_id: Optional[str] = None) -> List[BillingRate]:\n        \"\"\"List billing rates with optional filtering\"\"\"\n        query = self._build_list_billing_rates_query(client_id)\n        response = await self._execute(query)\n        return [BillingRate(**r) for r in response['data']['billingRates']]\n    \n    async def create_billing_rate(self, \n                                name: str,\n                                rate: float,\n                                client_id: Optional[str] = None,\n                                service_type: Optional[str] = None) -> BillingRate:\n        \"\"\"Create a new billing rate\"\"\"\n        data = {\n            \"name\": name,\n            \"rate\": rate\n        }\n        if client_id:\n            data[\"client_id\"] = client_id\n        if service_type:\n            data[\"service_type\"] = service_type\n            \n        mutation = self._build_create_billing_rate_mutation(data)\n        response = await self._execute(mutation)\n        return BillingRate(**response['data']['createBillingRate'])\n    \n    # Payment tracking\n    # Recurring billing setup\n    # Implement other billing and invoicing methods\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass InvoiceStatus(str, Enum):\n    DRAFT = \"draft\"\n    SENT = \"sent\"\n    PAID = \"paid\"\n    OVERDUE = \"overdue\"\n    CANCELLED = \"cancelled\"\n\nclass InvoiceItem:\n    description: str\n    quantity: float\n    unit_price: float\n    amount: float\n    tax_rate: Optional[float]\n    tax_amount: Optional[float]\n    time_entry_id: Optional[str]\n    # other fields\n\nclass Invoice:\n    id: str\n    client_id: str\n    invoice_number: str\n    status: InvoiceStatus\n    issue_date: datetime\n    due_date: datetime\n    items: List[InvoiceItem]\n    subtotal: float\n    tax_total: float\n    total: float\n    notes: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass BillingRate:\n    id: str\n    name: str\n    rate: float\n    client_id: Optional[str]\n    service_type: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass Payment:\n    id: str\n    invoice_id: str\n    amount: float\n    payment_date: datetime\n    payment_method: str\n    reference_number: Optional[str]\n    notes: Optional[str]\n    created_at: datetime\n    # other fields\n\nclass RecurringBillingFrequency(str, Enum):\n    WEEKLY = \"weekly\"\n    MONTHLY = \"monthly\"\n    QUARTERLY = \"quarterly\"\n    YEARLY = \"yearly\"\n\nclass RecurringBilling:\n    id: str\n    client_id: str\n    name: str\n    frequency: RecurringBillingFrequency\n    next_date: datetime\n    items: List[Dict[str, Any]]\n    active: bool\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_billing.py` that:\n1. Mock GraphQL responses for all operations\n2. Test invoice management (create, update, delete)\n3. Test invoice retrieval and listing with filters\n4. Test invoice generation from time entries\n5. Test invoice sending\n6. Test billing rate management\n7. Test payment tracking\n8. Test recurring billing setup\n9. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "low",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Payment Tracking Methods",
            "description": "Add methods to track payments for invoices, including creating, retrieving, updating, and listing payments.",
            "dependencies": [],
            "details": "Add the following methods to the BillingManager class:\n\n```python\nasync def get_payment(self, payment_id: str) -> Payment:\n    \"\"\"Get a payment by ID\"\"\"\n    query = self._build_get_payment_query(payment_id)\n    response = await self._execute(query)\n    return Payment(**response['data']['payment'])\n\nasync def list_payments(self, \n                       invoice_id: Optional[str] = None,\n                       client_id: Optional[str] = None,\n                       start_date: Optional[datetime] = None,\n                       end_date: Optional[datetime] = None) -> List[Payment]:\n    \"\"\"List payments with optional filtering\"\"\"\n    query = self._build_list_payments_query(invoice_id, client_id, start_date, end_date)\n    response = await self._execute(query)\n    return [Payment(**p) for p in response['data']['payments']]\n\nasync def create_payment(self, \n                       invoice_id: str,\n                       amount: float,\n                       payment_date: datetime,\n                       payment_method: str,\n                       reference_number: Optional[str] = None,\n                       notes: Optional[str] = None) -> Payment:\n    \"\"\"Record a new payment for an invoice\"\"\"\n    data = {\n        \"invoice_id\": invoice_id,\n        \"amount\": amount,\n        \"payment_date\": payment_date,\n        \"payment_method\": payment_method\n    }\n    if reference_number:\n        data[\"reference_number\"] = reference_number\n    if notes:\n        data[\"notes\"] = notes\n        \n    mutation = self._build_create_payment_mutation(data)\n    response = await self._execute(mutation)\n    return Payment(**response['data']['createPayment'])\n\nasync def update_payment(self, \n                       payment_id: str,\n                       amount: Optional[float] = None,\n                       payment_date: Optional[datetime] = None,\n                       payment_method: Optional[str] = None,\n                       reference_number: Optional[str] = None,\n                       notes: Optional[str] = None) -> Payment:\n    \"\"\"Update an existing payment\"\"\"\n    data = {}\n    if amount is not None:\n        data[\"amount\"] = amount\n    if payment_date is not None:\n        data[\"payment_date\"] = payment_date\n    if payment_method is not None:\n        data[\"payment_method\"] = payment_method\n    if reference_number is not None:\n        data[\"reference_number\"] = reference_number\n    if notes is not None:\n        data[\"notes\"] = notes\n        \n    mutation = self._build_update_payment_mutation(payment_id, data)\n    response = await self._execute(mutation)\n    return Payment(**response['data']['updatePayment'])\n\nasync def delete_payment(self, payment_id: str) -> bool:\n    \"\"\"Delete a payment record\"\"\"\n    mutation = self._build_delete_payment_mutation(payment_id)\n    response = await self._execute(mutation)\n    return response['data']['deletePayment']['success']\n```\n\nAlso implement the corresponding query/mutation builders:\n- _build_get_payment_query\n- _build_list_payments_query\n- _build_create_payment_mutation\n- _build_update_payment_mutation\n- _build_delete_payment_mutation",
            "status": "pending",
            "testStrategy": "Create unit tests in `tests/test_billing.py` that:\n1. Mock GraphQL responses for all payment operations\n2. Test payment creation with required and optional fields\n3. Test payment retrieval by ID\n4. Test payment listing with various filters\n5. Test payment updates\n6. Test payment deletion\n7. Verify proper error handling for invalid inputs or failed operations"
          },
          {
            "id": 2,
            "title": "Implement Recurring Billing Setup",
            "description": "Add methods to manage recurring billing profiles, including creation, retrieval, updating, and activation/deactivation.",
            "dependencies": [],
            "details": "Add the following methods to the BillingManager class:\n\n```python\nasync def get_recurring_billing(self, recurring_id: str) -> RecurringBilling:\n    \"\"\"Get a recurring billing profile by ID\"\"\"\n    query = self._build_get_recurring_billing_query(recurring_id)\n    response = await self._execute(query)\n    return RecurringBilling(**response['data']['recurringBilling'])\n\nasync def list_recurring_billings(self, \n                                client_id: Optional[str] = None,\n                                active_only: bool = False) -> List[RecurringBilling]:\n    \"\"\"List recurring billing profiles with optional filtering\"\"\"\n    query = self._build_list_recurring_billings_query(client_id, active_only)\n    response = await self._execute(query)\n    return [RecurringBilling(**r) for r in response['data']['recurringBillings']]\n\nasync def create_recurring_billing(self, \n                                 client_id: str,\n                                 name: str,\n                                 frequency: RecurringBillingFrequency,\n                                 next_date: datetime,\n                                 items: List[Dict[str, Any]],\n                                 active: bool = True) -> RecurringBilling:\n    \"\"\"Create a new recurring billing profile\"\"\"\n    data = {\n        \"client_id\": client_id,\n        \"name\": name,\n        \"frequency\": frequency,\n        \"next_date\": next_date,\n        \"items\": items,\n        \"active\": active\n    }\n    \n    mutation = self._build_create_recurring_billing_mutation(data)\n    response = await self._execute(mutation)\n    return RecurringBilling(**response['data']['createRecurringBilling'])\n\nasync def update_recurring_billing(self, \n                                 recurring_id: str,\n                                 name: Optional[str] = None,\n                                 frequency: Optional[RecurringBillingFrequency] = None,\n                                 next_date: Optional[datetime] = None,\n                                 items: Optional[List[Dict[str, Any]]] = None) -> RecurringBilling:\n    \"\"\"Update an existing recurring billing profile\"\"\"\n    data = {}\n    if name is not None:\n        data[\"name\"] = name\n    if frequency is not None:\n        data[\"frequency\"] = frequency\n    if next_date is not None:\n        data[\"next_date\"] = next_date\n    if items is not None:\n        data[\"items\"] = items\n        \n    mutation = self._build_update_recurring_billing_mutation(recurring_id, data)\n    response = await self._execute(mutation)\n    return RecurringBilling(**response['data']['updateRecurringBilling'])\n\nasync def activate_recurring_billing(self, recurring_id: str) -> RecurringBilling:\n    \"\"\"Activate a recurring billing profile\"\"\"\n    mutation = self._build_activate_recurring_billing_mutation(recurring_id)\n    response = await self._execute(mutation)\n    return RecurringBilling(**response['data']['activateRecurringBilling'])\n\nasync def deactivate_recurring_billing(self, recurring_id: str) -> RecurringBilling:\n    \"\"\"Deactivate a recurring billing profile\"\"\"\n    mutation = self._build_deactivate_recurring_billing_mutation(recurring_id)\n    response = await self._execute(mutation)\n    return RecurringBilling(**response['data']['deactivateRecurringBilling'])\n\nasync def generate_invoice_from_recurring(self, recurring_id: str) -> Invoice:\n    \"\"\"Manually generate an invoice from a recurring billing profile\"\"\"\n    mutation = self._build_generate_invoice_from_recurring_mutation(recurring_id)\n    response = await self._execute(mutation)\n    return Invoice(**response['data']['generateInvoiceFromRecurring'])\n```\n\nAlso implement the corresponding query/mutation builders:\n- _build_get_recurring_billing_query\n- _build_list_recurring_billings_query\n- _build_create_recurring_billing_mutation\n- _build_update_recurring_billing_mutation\n- _build_activate_recurring_billing_mutation\n- _build_deactivate_recurring_billing_mutation\n- _build_generate_invoice_from_recurring_mutation",
            "status": "pending",
            "testStrategy": "Create unit tests in `tests/test_billing.py` that:\n1. Mock GraphQL responses for all recurring billing operations\n2. Test recurring billing profile creation with various configurations\n3. Test recurring billing retrieval by ID\n4. Test recurring billing listing with filters\n5. Test recurring billing updates\n6. Test activation and deactivation\n7. Test invoice generation from recurring billing\n8. Verify proper error handling for invalid inputs or failed operations"
          },
          {
            "id": 3,
            "title": "Implement Invoice Approval Workflows",
            "description": "Add methods to handle invoice approval workflows, including submitting for approval, approving, rejecting, and tracking approval status.",
            "dependencies": [],
            "details": "Add the following methods to the BillingManager class:\n\n```python\nasync def submit_invoice_for_approval(self, invoice_id: str, approver_ids: List[str]) -> Invoice:\n    \"\"\"Submit an invoice for approval\"\"\"\n    mutation = self._build_submit_invoice_for_approval_mutation(invoice_id, approver_ids)\n    response = await self._execute(mutation)\n    return Invoice(**response['data']['submitInvoiceForApproval'])\n\nasync def approve_invoice(self, invoice_id: str, approver_id: str, comments: Optional[str] = None) -> Invoice:\n    \"\"\"Approve an invoice\"\"\"\n    data = {\n        \"invoice_id\": invoice_id,\n        \"approver_id\": approver_id\n    }\n    if comments:\n        data[\"comments\"] = comments\n        \n    mutation = self._build_approve_invoice_mutation(data)\n    response = await self._execute(mutation)\n    return Invoice(**response['data']['approveInvoice'])\n\nasync def reject_invoice(self, invoice_id: str, approver_id: str, reason: str) -> Invoice:\n    \"\"\"Reject an invoice\"\"\"\n    mutation = self._build_reject_invoice_mutation(invoice_id, approver_id, reason)\n    response = await self._execute(mutation)\n    return Invoice(**response['data']['rejectInvoice'])\n\nasync def get_invoice_approval_status(self, invoice_id: str) -> Dict[str, Any]:\n    \"\"\"Get the approval status of an invoice\"\"\"\n    query = self._build_get_invoice_approval_status_query(invoice_id)\n    response = await self._execute(query)\n    return response['data']['invoiceApprovalStatus']\n\nasync def list_pending_approvals(self, approver_id: Optional[str] = None) -> List[Invoice]:\n    \"\"\"List invoices pending approval, optionally filtered by approver\"\"\"\n    query = self._build_list_pending_approvals_query(approver_id)\n    response = await self._execute(query)\n    return [Invoice(**i) for i in response['data']['pendingApprovals']]\n\nasync def cancel_approval_request(self, invoice_id: str) -> Invoice:\n    \"\"\"Cancel an approval request for an invoice\"\"\"\n    mutation = self._build_cancel_approval_request_mutation(invoice_id)\n    response = await self._execute(mutation)\n    return Invoice(**response['data']['cancelApprovalRequest'])\n```\n\nAlso implement the corresponding query/mutation builders:\n- _build_submit_invoice_for_approval_mutation\n- _build_approve_invoice_mutation\n- _build_reject_invoice_mutation\n- _build_get_invoice_approval_status_query\n- _build_list_pending_approvals_query\n- _build_cancel_approval_request_mutation\n\nUpdate the Invoice type in types.py to include approval-related fields:\n\n```python\nclass ApprovalStatus(str, Enum):\n    PENDING = \"pending\"\n    APPROVED = \"approved\"\n    REJECTED = \"rejected\"\n    NOT_SUBMITTED = \"not_submitted\"\n\nclass ApproverAction:\n    approver_id: str\n    status: ApprovalStatus\n    timestamp: datetime\n    comments: Optional[str]\n\nclass Invoice:\n    # Existing fields...\n    approval_status: ApprovalStatus\n    approvers: List[str]\n    approval_history: List[ApproverAction]\n```",
            "status": "pending",
            "testStrategy": "Create unit tests in `tests/test_billing.py` that:\n1. Mock GraphQL responses for all approval workflow operations\n2. Test invoice submission for approval\n3. Test invoice approval and rejection\n4. Test approval status retrieval\n5. Test listing of pending approvals\n6. Test cancellation of approval requests\n7. Verify proper error handling for invalid inputs or failed operations\n8. Test approval workflow state transitions"
          },
          {
            "id": 4,
            "title": "Implement Query and Mutation Builders",
            "description": "Implement all the GraphQL query and mutation builder methods needed for the BillingManager class.",
            "dependencies": [
              "11.1",
              "11.2",
              "11.3"
            ],
            "details": "Implement the following query and mutation builder methods in the BillingManager class:\n\n```python\ndef _build_get_invoice_query(self, invoice_id: str) -> Dict[str, Any]:\n    return {\n        \"query\": \"\"\"\n        query GetInvoice($id: ID!) {\n            invoice(id: $id) {\n                id\n                client_id\n                invoice_number\n                status\n                issue_date\n                due_date\n                items {\n                    description\n                    quantity\n                    unit_price\n                    amount\n                    tax_rate\n                    tax_amount\n                    time_entry_id\n                }\n                subtotal\n                tax_total\n                total\n                notes\n                created_at\n                updated_at\n                approval_status\n                approvers\n                approval_history {\n                    approver_id\n                    status\n                    timestamp\n                    comments\n                }\n            }\n        }\n        \"\"\",\n        \"variables\": {\"id\": invoice_id}\n    }\n\ndef _build_list_invoices_query(self, client_id: Optional[str], status: Optional[InvoiceStatus], \n                             start_date: Optional[datetime], end_date: Optional[datetime]) -> Dict[str, Any]:\n    variables = {}\n    if client_id:\n        variables[\"client_id\"] = client_id\n    if status:\n        variables[\"status\"] = status\n    if start_date:\n        variables[\"start_date\"] = start_date.isoformat()\n    if end_date:\n        variables[\"end_date\"] = end_date.isoformat()\n        \n    return {\n        \"query\": \"\"\"\n        query ListInvoices($client_id: ID, $status: InvoiceStatus, $start_date: DateTime, $end_date: DateTime) {\n            invoices(client_id: $client_id, status: $status, start_date: $start_date, end_date: $end_date) {\n                id\n                client_id\n                invoice_number\n                status\n                issue_date\n                due_date\n                subtotal\n                tax_total\n                total\n                created_at\n                updated_at\n                approval_status\n            }\n        }\n        \"\"\",\n        \"variables\": variables\n    }\n\ndef _build_create_invoice_mutation(self, data: Dict[str, Any]) -> Dict[str, Any]:\n    return {\n        \"query\": \"\"\"\n        mutation CreateInvoice($input: CreateInvoiceInput!) {\n            createInvoice(input: $input) {\n                id\n                client_id\n                invoice_number\n                status\n                issue_date\n                due_date\n                items {\n                    description\n                    quantity\n                    unit_price\n                    amount\n                    tax_rate\n                    tax_amount\n                    time_entry_id\n                }\n                subtotal\n                tax_total\n                total\n                notes\n                created_at\n                updated_at\n            }\n        }\n        \"\"\",\n        \"variables\": {\"input\": data}\n    }\n\n# Implement all other query/mutation builders for:\n# - Invoice management\n# - Billing rate management\n# - Payment tracking\n# - Recurring billing\n# - Invoice approval workflows\n\ndef _build_get_payment_query(self, payment_id: str) -> Dict[str, Any]:\n    return {\n        \"query\": \"\"\"\n        query GetPayment($id: ID!) {\n            payment(id: $id) {\n                id\n                invoice_id\n                amount\n                payment_date\n                payment_method\n                reference_number\n                notes\n                created_at\n            }\n        }\n        \"\"\",\n        \"variables\": {\"id\": payment_id}\n    }\n\ndef _build_list_payments_query(self, invoice_id: Optional[str], client_id: Optional[str],\n                             start_date: Optional[datetime], end_date: Optional[datetime]) -> Dict[str, Any]:\n    variables = {}\n    if invoice_id:\n        variables[\"invoice_id\"] = invoice_id\n    if client_id:\n        variables[\"client_id\"] = client_id\n    if start_date:\n        variables[\"start_date\"] = start_date.isoformat()\n    if end_date:\n        variables[\"end_date\"] = end_date.isoformat()\n        \n    return {\n        \"query\": \"\"\"\n        query ListPayments($invoice_id: ID, $client_id: ID, $start_date: DateTime, $end_date: DateTime) {\n            payments(invoice_id: $invoice_id, client_id: $client_id, start_date: $start_date, end_date: $end_date) {\n                id\n                invoice_id\n                amount\n                payment_date\n                payment_method\n                reference_number\n                notes\n                created_at\n            }\n        }\n        \"\"\",\n        \"variables\": variables\n    }\n\n# Continue implementing all remaining query/mutation builders\n```\n\nImplement all the remaining query and mutation builders for the methods defined in the previous subtasks, following the same pattern. Each builder should construct the appropriate GraphQL query or mutation with variables.",
            "status": "pending",
            "testStrategy": "The query and mutation builders will be indirectly tested through the unit tests for the methods that use them. However, you can also create specific tests that:\n\n1. Verify that each builder generates the expected GraphQL query structure\n2. Check that variables are correctly incorporated into the queries\n3. Ensure that optional parameters are handled properly\n4. Test edge cases like empty lists or null values"
          },
          {
            "id": 5,
            "title": "Complete Type Definitions and Documentation",
            "description": "Finalize all type definitions in types.py and add comprehensive documentation for the BillingManager class.",
            "dependencies": [
              "11.1",
              "11.2",
              "11.3",
              "11.4"
            ],
            "details": "1. Complete the type definitions in types.py:\n\n```python\nclass InvoiceStatus(str, Enum):\n    DRAFT = \"draft\"\n    SENT = \"sent\"\n    PAID = \"paid\"\n    OVERDUE = \"overdue\"\n    CANCELLED = \"cancelled\"\n\nclass ApprovalStatus(str, Enum):\n    PENDING = \"pending\"\n    APPROVED = \"approved\"\n    REJECTED = \"rejected\"\n    NOT_SUBMITTED = \"not_submitted\"\n\nclass ApproverAction:\n    approver_id: str\n    status: ApprovalStatus\n    timestamp: datetime\n    comments: Optional[str]\n\nclass InvoiceItem:\n    description: str\n    quantity: float\n    unit_price: float\n    amount: float\n    tax_rate: Optional[float]\n    tax_amount: Optional[float]\n    time_entry_id: Optional[str]\n\nclass Invoice:\n    id: str\n    client_id: str\n    invoice_number: str\n    status: InvoiceStatus\n    issue_date: datetime\n    due_date: datetime\n    items: List[InvoiceItem]\n    subtotal: float\n    tax_total: float\n    total: float\n    notes: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n    approval_status: ApprovalStatus\n    approvers: List[str]\n    approval_history: List[ApproverAction]\n\nclass BillingRate:\n    id: str\n    name: str\n    rate: float\n    client_id: Optional[str]\n    service_type: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n\nclass Payment:\n    id: str\n    invoice_id: str\n    amount: float\n    payment_date: datetime\n    payment_method: str\n    reference_number: Optional[str]\n    notes: Optional[str]\n    created_at: datetime\n\nclass RecurringBillingFrequency(str, Enum):\n    WEEKLY = \"weekly\"\n    MONTHLY = \"monthly\"\n    QUARTERLY = \"quarterly\"\n    YEARLY = \"yearly\"\n\nclass RecurringBilling:\n    id: str\n    client_id: str\n    name: str\n    frequency: RecurringBillingFrequency\n    next_date: datetime\n    items: List[Dict[str, Any]]\n    active: bool\n    created_at: datetime\n    updated_at: datetime\n```\n\n2. Add comprehensive class and method documentation to the BillingManager class:\n\n```python\nclass BillingManager(BaseManager):\n    \"\"\"Manager for SuperOps Billing & Invoicing API operations.\n    \n    This class provides methods for managing all aspects of billing and invoicing, including:\n    - Invoice creation, retrieval, updating, and deletion\n    - Invoice generation from time entries\n    - Billing rate management\n    - Payment tracking\n    - Recurring billing setup\n    - Invoice approval workflows\n    \n    All methods are asynchronous and return typed objects or lists of objects.\n    \"\"\"\n```\n\n3. Add usage examples to the module docstring:\n\n```python\n\"\"\"SuperOps Billing & Invoicing API Manager.\n\nThis module provides a BillingManager class for interacting with the SuperOps Billing & Invoicing API.\n\nExample usage:\n\n    # Create a new invoice\n    invoice = await client.billing.create_invoice(\n        client_id=\"client123\",\n        items=[\n            {\n                \"description\": \"Consulting services\",\n                \"quantity\": 10,\n                \"unit_price\": 150.0\n            }\n        ],\n        due_date=datetime.now() + timedelta(days=30)\n    )\n    \n    # Generate an invoice from time entries\n    invoice = await client.billing.generate_from_time_entries(\n        client_id=\"client123\",\n        time_entry_ids=[\"entry1\", \"entry2\", \"entry3\"],\n        due_date=datetime.now() + timedelta(days=30)\n    )\n    \n    # Record a payment\n    payment = await client.billing.create_payment(\n        invoice_id=\"invoice123\",\n        amount=1500.0,\n        payment_date=datetime.now(),\n        payment_method=\"credit_card\",\n        reference_number=\"tx_12345\"\n    )\n    \n    # Set up recurring billing\n    recurring = await client.billing.create_recurring_billing(\n        client_id=\"client123\",\n        name=\"Monthly Maintenance\",\n        frequency=RecurringBillingFrequency.MONTHLY,\n        next_date=datetime.now() + timedelta(days=30),\n        items=[\n            {\n                \"description\": \"Server maintenance\",\n                \"quantity\": 1,\n                \"unit_price\": 500.0\n            }\n        ]\n    )\n\"\"\"\n```\n\n4. Ensure all methods have proper docstrings with parameter descriptions and return type information.",
            "status": "pending",
            "testStrategy": "1. Verify that all type definitions are properly imported and used in the BillingManager class\n2. Check that documentation is comprehensive and follows the project's style guidelines\n3. Ensure examples in the documentation are accurate and executable\n4. Validate that all public methods have proper docstrings with parameter and return type information"
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Inventory Management API",
        "description": "Create an InventoryManager class to handle product catalog management, stock level tracking, purchase order management, vendor management, and product-to-asset conversion.",
        "details": "Create a new file `inventory.py` in the managers directory:\n\n```python\nfrom typing import List, Optional, Dict, Any, Union\nfrom datetime import datetime\n\nfrom ..base import BaseManager\nfrom ..types import Product, StockLevel, PurchaseOrder, Vendor\n\nclass InventoryManager(BaseManager):\n    \"\"\"Manager for SuperOps Inventory Management API operations\"\"\"\n    \n    # Product catalog management\n    async def get_product(self, product_id: str) -> Product:\n        \"\"\"Get a product by ID\"\"\"\n        query = self._build_get_product_query(product_id)\n        response = await self._execute(query)\n        return Product(**response['data']['product'])\n    \n    async def list_products(self, \n                           vendor_id: Optional[str] = None,\n                           category: Optional[str] = None) -> List[Product]:\n        \"\"\"List products with optional filtering\"\"\"\n        query = self._build_list_products_query(vendor_id, category)\n        response = await self._execute(query)\n        return [Product(**p) for p in response['data']['products']]\n    \n    async def create_product(self, \n                           name: str,\n                           sku: str,\n                           price: float,\n                           vendor_id: Optional[str] = None,\n                           description: Optional[str] = None,\n                           category: Optional[str] = None) -> Product:\n        \"\"\"Create a new product\"\"\"\n        data = {\n            \"name\": name,\n            \"sku\": sku,\n            \"price\": price\n        }\n        if vendor_id:\n            data[\"vendor_id\"] = vendor_id\n        if description:\n            data[\"description\"] = description\n        if category:\n            data[\"category\"] = category\n            \n        mutation = self._build_create_product_mutation(data)\n        response = await self._execute(mutation)\n        return Product(**response['data']['createProduct'])\n    \n    async def update_product(self, \n                           product_id: str,\n                           name: Optional[str] = None,\n                           price: Optional[float] = None,\n                           description: Optional[str] = None,\n                           category: Optional[str] = None) -> Product:\n        \"\"\"Update an existing product\"\"\"\n        data = {}\n        if name is not None:\n            data[\"name\"] = name\n        if price is not None:\n            data[\"price\"] = price\n        if description is not None:\n            data[\"description\"] = description\n        if category is not None:\n            data[\"category\"] = category\n            \n        mutation = self._build_update_product_mutation(product_id, data)\n        response = await self._execute(mutation)\n        return Product(**response['data']['updateProduct'])\n    \n    async def delete_product(self, product_id: str) -> bool:\n        \"\"\"Delete a product\"\"\"\n        mutation = self._build_delete_product_mutation(product_id)\n        response = await self._execute(mutation)\n        return response['data']['deleteProduct']['success']\n    \n    # Stock level tracking\n    async def get_stock_level(self, product_id: str) -> StockLevel:\n        \"\"\"Get stock level for a product\"\"\"\n        query = self._build_get_stock_level_query(product_id)\n        response = await self._execute(query)\n        return StockLevel(**response['data']['stockLevel'])\n    \n    async def update_stock_level(self, \n                               product_id: str,\n                               quantity: int,\n                               notes: Optional[str] = None) -> StockLevel:\n        \"\"\"Update stock level for a product\"\"\"\n        data = {\n            \"product_id\": product_id,\n            \"quantity\": quantity\n        }\n        if notes:\n            data[\"notes\"] = notes\n            \n        mutation = self._build_update_stock_level_mutation(data)\n        response = await self._execute(mutation)\n        return StockLevel(**response['data']['updateStockLevel'])\n    \n    # Purchase order management\n    async def create_purchase_order(self, \n                                  vendor_id: str,\n                                  items: List[Dict[str, Any]],\n                                  expected_delivery_date: datetime,\n                                  notes: Optional[str] = None) -> PurchaseOrder:\n        \"\"\"Create a new purchase order\"\"\"\n        data = {\n            \"vendor_id\": vendor_id,\n            \"items\": items,\n            \"expected_delivery_date\": expected_delivery_date\n        }\n        if notes:\n            data[\"notes\"] = notes\n            \n        mutation = self._build_create_purchase_order_mutation(data)\n        response = await self._execute(mutation)\n        return PurchaseOrder(**response['data']['createPurchaseOrder'])\n    \n    # Vendor management\n    async def get_vendor(self, vendor_id: str) -> Vendor:\n        \"\"\"Get a vendor by ID\"\"\"\n        query = self._build_get_vendor_query(vendor_id)\n        response = await self._execute(query)\n        return Vendor(**response['data']['vendor'])\n    \n    async def list_vendors(self) -> List[Vendor]:\n        \"\"\"List all vendors\"\"\"\n        query = self._build_list_vendors_query()\n        response = await self._execute(query)\n        return [Vendor(**v) for v in response['data']['vendors']]\n    \n    async def create_vendor(self, \n                          name: str,\n                          contact_info: Dict[str, Any],\n                          description: Optional[str] = None) -> Vendor:\n        \"\"\"Create a new vendor\"\"\"\n        data = {\n            \"name\": name,\n            \"contact_info\": contact_info\n        }\n        if description:\n            data[\"description\"] = description\n            \n        mutation = self._build_create_vendor_mutation(data)\n        response = await self._execute(mutation)\n        return Vendor(**response['data']['createVendor'])\n    \n    # Product-to-asset conversion\n    async def convert_to_asset(self, \n                             product_id: str,\n                             client_id: str,\n                             site_id: Optional[str] = None,\n                             asset_data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Convert a product to an asset\"\"\"\n        data = {\n            \"product_id\": product_id,\n            \"client_id\": client_id\n        }\n        if site_id:\n            data[\"site_id\"] = site_id\n        if asset_data:\n            data[\"asset_data\"] = asset_data\n            \n        mutation = self._build_convert_to_asset_mutation(data)\n        response = await self._execute(mutation)\n        return response['data']['convertProductToAsset']\n    \n    # Implement other inventory management methods\n    \n    # Implement query/mutation builders\n```\n\nAdd corresponding type definitions in `types.py`:\n\n```python\nclass Product:\n    id: str\n    name: str\n    sku: str\n    description: Optional[str]\n    price: float\n    vendor_id: Optional[str]\n    category: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass StockLevel:\n    product_id: str\n    quantity: int\n    last_updated: datetime\n    reorder_threshold: Optional[int]\n    reorder_quantity: Optional[int]\n    # other fields\n\nclass PurchaseOrderStatus(str, Enum):\n    DRAFT = \"draft\"\n    ORDERED = \"ordered\"\n    PARTIAL = \"partial\"\n    RECEIVED = \"received\"\n    CANCELLED = \"cancelled\"\n\nclass PurchaseOrderItem:\n    product_id: str\n    quantity: int\n    unit_price: float\n    total_price: float\n    received_quantity: int\n    # other fields\n\nclass PurchaseOrder:\n    id: str\n    vendor_id: str\n    po_number: str\n    status: PurchaseOrderStatus\n    items: List[PurchaseOrderItem]\n    total: float\n    order_date: datetime\n    expected_delivery_date: datetime\n    notes: Optional[str]\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n\nclass Vendor:\n    id: str\n    name: str\n    description: Optional[str]\n    contact_info: Dict[str, Any]  # Complex structure with address, phone, email, etc.\n    created_at: datetime\n    updated_at: datetime\n    # other fields\n```",
        "testStrategy": "Create unit tests in `tests/test_inventory.py` that:\n1. Mock GraphQL responses for all operations\n2. Test product management (create, update, delete)\n3. Test product retrieval and listing with filters\n4. Test stock level tracking\n5. Test purchase order management\n6. Test vendor management\n7. Test product-to-asset conversion\n8. Test error handling for invalid inputs and API errors\n\nEnsure test coverage is at least 80% for the new manager.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GraphQL query builders for product and stock management",
            "description": "Create the GraphQL query and mutation builder methods for product catalog management and stock level tracking operations in the InventoryManager class.",
            "dependencies": [],
            "details": "Implement the following methods in the InventoryManager class:\n\n1. `_build_get_product_query(product_id)`: Build GraphQL query to fetch a product by ID\n2. `_build_list_products_query(vendor_id, category)`: Build GraphQL query to list products with optional filters\n3. `_build_create_product_mutation(data)`: Build GraphQL mutation to create a new product\n4. `_build_update_product_mutation(product_id, data)`: Build GraphQL mutation to update an existing product\n5. `_build_delete_product_mutation(product_id)`: Build GraphQL mutation to delete a product\n6. `_build_get_stock_level_query(product_id)`: Build GraphQL query to get stock level for a product\n7. `_build_update_stock_level_mutation(data)`: Build GraphQL mutation to update stock level\n\nEach method should return a properly formatted GraphQL query/mutation string with variables as needed.",
            "status": "pending",
            "testStrategy": "Test each query builder method to ensure it generates the correct GraphQL syntax with proper variable handling. Verify the structure matches the expected API schema."
          },
          {
            "id": 2,
            "title": "Implement GraphQL query builders for purchase orders and vendors",
            "description": "Create the GraphQL query and mutation builder methods for purchase order management and vendor management operations in the InventoryManager class.",
            "dependencies": [
              "12.1"
            ],
            "details": "Implement the following methods in the InventoryManager class:\n\n1. `_build_create_purchase_order_mutation(data)`: Build GraphQL mutation to create a new purchase order\n2. `_build_get_purchase_order_query(po_id)`: Build GraphQL query to fetch a purchase order by ID\n3. `_build_update_purchase_order_mutation(po_id, data)`: Build GraphQL mutation to update a purchase order\n4. `_build_get_vendor_query(vendor_id)`: Build GraphQL query to fetch a vendor by ID\n5. `_build_list_vendors_query()`: Build GraphQL query to list all vendors\n6. `_build_create_vendor_mutation(data)`: Build GraphQL mutation to create a new vendor\n\nEnsure proper handling of complex nested data structures, especially for purchase order items.",
            "status": "pending",
            "testStrategy": "Test each query builder method to ensure it generates the correct GraphQL syntax. Verify proper handling of complex nested structures like purchase order items and vendor contact information."
          },
          {
            "id": 3,
            "title": "Implement product-to-asset conversion and additional inventory methods",
            "description": "Complete the implementation of the product-to-asset conversion functionality and add any missing inventory management methods required for a complete API.",
            "dependencies": [
              "12.1",
              "12.2"
            ],
            "details": "1. Implement `_build_convert_to_asset_mutation(data)`: Build GraphQL mutation to convert a product to an asset\n2. Add additional inventory management methods:\n   - `async def get_purchase_order(self, po_id: str) -> PurchaseOrder`: Get purchase order by ID\n   - `async def list_purchase_orders(self, vendor_id: Optional[str] = None, status: Optional[PurchaseOrderStatus] = None) -> List[PurchaseOrder]`: List purchase orders with optional filtering\n   - `async def update_purchase_order(self, po_id: str, status: Optional[PurchaseOrderStatus] = None, items: Optional[List[Dict[str, Any]]] = None, notes: Optional[str] = None) -> PurchaseOrder`: Update purchase order\n   - `async def update_vendor(self, vendor_id: str, name: Optional[str] = None, contact_info: Optional[Dict[str, Any]] = None, description: Optional[str] = None) -> Vendor`: Update vendor\n   - `async def delete_vendor(self, vendor_id: str) -> bool`: Delete vendor\n\nImplement the corresponding query/mutation builders for these methods.",
            "status": "pending",
            "testStrategy": "Test the new methods with various input combinations. Verify the product-to-asset conversion handles all required fields correctly. Test edge cases for purchase order updates."
          },
          {
            "id": 4,
            "title": "Complete type definitions in types.py",
            "description": "Finalize the type definitions for Product, StockLevel, PurchaseOrder, PurchaseOrderItem, PurchaseOrderStatus, and Vendor classes in the types.py file.",
            "dependencies": [],
            "details": "Complete the type definitions in types.py by:\n\n1. Implementing the `__init__` method for each class to properly parse API responses\n2. Adding any missing fields based on the API documentation\n3. Adding proper type hints and docstrings\n4. Implementing any helper methods needed for data manipulation\n5. Ensuring proper handling of optional fields\n6. Adding proper validation for enum values (especially for PurchaseOrderStatus)\n7. Implementing proper datetime parsing for date fields\n\nEnsure all classes properly inherit from any base classes used in the project for consistent behavior.",
            "status": "pending",
            "testStrategy": "Create unit tests that instantiate each type with sample API response data. Test parsing of various field formats, especially dates and nested objects. Verify proper handling of missing optional fields."
          },
          {
            "id": 5,
            "title": "Create comprehensive unit tests for InventoryManager",
            "description": "Develop a complete test suite for the InventoryManager class that covers all implemented functionality with proper mocking of API responses.",
            "dependencies": [
              "12.1",
              "12.2",
              "12.3",
              "12.4"
            ],
            "details": "Create a new file `tests/test_inventory.py` with the following test cases:\n\n1. Test product management:\n   - test_get_product\n   - test_list_products (with and without filters)\n   - test_create_product\n   - test_update_product\n   - test_delete_product\n\n2. Test stock level tracking:\n   - test_get_stock_level\n   - test_update_stock_level\n\n3. Test purchase order management:\n   - test_create_purchase_order\n   - test_get_purchase_order\n   - test_list_purchase_orders\n   - test_update_purchase_order\n\n4. Test vendor management:\n   - test_get_vendor\n   - test_list_vendors\n   - test_create_vendor\n   - test_update_vendor\n   - test_delete_vendor\n\n5. Test product-to-asset conversion:\n   - test_convert_to_asset\n\nUse appropriate mocking techniques to simulate API responses. Include both success and error scenarios.",
            "status": "pending",
            "testStrategy": "Use pytest fixtures to set up test data. Mock GraphQL responses using the appropriate mocking framework. Test both successful API calls and error handling. Verify proper parsing of responses into the defined types."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-02T13:59:54.044Z",
      "updated": "2025-09-02T16:52:39.968Z",
      "description": "Tasks for master context"
    }
  }
}